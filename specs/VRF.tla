------------------------------ MODULE VRF ------------------------------
(**************************************************************************)
(* Verifiable Random Function (VRF) specification for Alpenglow protocol  *)
(* This module provides VRF key generation, proof creation, verification, *)
(* and leader selection logic with cryptographic properties.              *)
(**************************************************************************)

EXTENDS Integers, Sequences, FiniteSets, TLC, Types, Utils, Crypto

CONSTANTS
    VRFKeyPairs,        \* Set of VRF key pairs for validators
    MaxVRFOutput,       \* Maximum VRF output value (for normalization)
    VRFSeed             \* Global VRF seed for determinism

VARIABLES
    vrfProofs,          \* VRF proofs generated by validators
    vrfOutputs,         \* VRF outputs for leader selection
    leaderSchedule      \* Computed leader schedule using VRF

----------------------------------------------------------------------------
(* VRF Types and Structures *)

\* VRF key pair structure
VRFKeyPair == [
    validator: ValidatorId,
    publicKey: Nat,
    privateKey: Nat,
    valid: BOOLEAN
]

\* VRF proof structure
VRFProof == [
    validator: ValidatorId,
    input: Nat,
    output: Nat,
    proof: Nat,
    publicKey: Nat,
    valid: BOOLEAN
]

\* VRF evaluation result
VRFEvaluation == [
    validator: ValidatorId,
    input: Nat,
    output: Nat,
    proof: VRFProof,
    verified: BOOLEAN
]

----------------------------------------------------------------------------
(* VRF Key Generation *)

\* Generate VRF key pair for a validator
VRFGenerateKeyPair(validator, seed) ==
    LET privateKey == (validator * seed * 7919) % 999999
        publicKey == (privateKey * 2) % 999999
    IN [
        validator |-> validator,
        publicKey |-> publicKey,
        privateKey |-> privateKey,
        valid |-> TRUE
    ]

\* Get public key for validator
VRFGetPublicKey(validator) ==
    IF \E kp \in VRFKeyPairs : kp.validator = validator
    THEN (CHOOSE kp \in VRFKeyPairs : kp.validator = validator).publicKey
    ELSE 0

\* Get private key for validator (only for honest validators)
VRFGetPrivateKey(validator) ==
    IF \E kp \in VRFKeyPairs : kp.validator = validator
    THEN (CHOOSE kp \in VRFKeyPairs : kp.validator = validator).privateKey
    ELSE 0

\* Check if validator has valid VRF keys
VRFHasValidKeys(validator) ==
    \E kp \in VRFKeyPairs : 
        /\ kp.validator = validator
        /\ kp.valid

----------------------------------------------------------------------------
(* VRF Core Operations *)

\* VRF evaluation function (deterministic pseudorandom function)
VRFEvaluate(privateKey, input) ==
    LET hash1 == (privateKey * input * 991) % MaxVRFOutput
        hash2 == (hash1 * 997 + input * 983) % MaxVRFOutput
        output == (hash1 + hash2) % MaxVRFOutput
    IN output

\* VRF proof generation
VRFProve(privateKey, input) ==
    LET output == VRFEvaluate(privateKey, input)
        \* Proof is a cryptographic proof that output was computed correctly
        proof == (privateKey * input * output * 7919) % 999999
    IN [
        input |-> input,
        output |-> output,
        proof |-> proof,
        valid |-> TRUE
    ]

\* VRF proof verification
VRFVerify(publicKey, input, proof, output) ==
    LET \* Verify that the proof is consistent with public key and input
        expectedProofHash == (publicKey * input * output * 7919) % 999999
        \* Check VRF uniqueness property
        deterministicOutput == VRFEvaluate(publicKey \div 2, input)  \* Derive private key
    IN /\ proof = expectedProofHash
       /\ output = deterministicOutput
       /\ output >= 0
       /\ output < MaxVRFOutput

\* VRF proof verification with proof object
VRFVerifyProof(publicKey, vrfProof) ==
    VRFVerify(publicKey, vrfProof.input, vrfProof.proof, vrfProof.output)

\* Generate VRF proof for validator
VRFGenerateProof(validator, input) ==
    IF VRFHasValidKeys(validator)
    THEN LET privateKey == VRFGetPrivateKey(validator)
             publicKey == VRFGetPublicKey(validator)
             proofData == VRFProve(privateKey, input)
         IN [
             validator |-> validator,
             input |-> input,
             output |-> proofData.output,
             proof |-> proofData.proof,
             publicKey |-> publicKey,
             valid |-> proofData.valid
         ]
    ELSE [
        validator |-> validator,
        input |-> input,
        output |-> 0,
        proof |-> 0,
        publicKey |-> 0,
        valid |-> FALSE
    ]

\* Verify VRF proof from validator
VRFVerifyValidatorProof(validator, vrfProof) ==
    LET publicKey == VRFGetPublicKey(validator)
    IN /\ vrfProof.validator = validator
       /\ vrfProof.publicKey = publicKey
       /\ VRFVerifyProof(publicKey, vrfProof)

----------------------------------------------------------------------------
(* VRF Properties *)

\* VRF Uniqueness: Same input always produces same output for same key
VRFUniquenessProperty ==
    \A validator \in ValidatorId, input \in Nat :
        VRFHasValidKeys(validator) =>
            LET proof1 == VRFGenerateProof(validator, input)
                proof2 == VRFGenerateProof(validator, input)
            IN proof1.output = proof2.output

\* VRF Unpredictability: Output appears random without private key
VRFUnpredictabilityProperty ==
    \A validator \in ValidatorId, input1, input2 \in Nat :
        /\ VRFHasValidKeys(validator)
        /\ input1 # input2
        => LET proof1 == VRFGenerateProof(validator, input1)
               proof2 == VRFGenerateProof(validator, input2)
           IN proof1.output # proof2.output  \* Different inputs yield different outputs

\* VRF Verifiability: Proofs can be publicly verified
VRFVerifiabilityProperty ==
    \A validator \in ValidatorId, input \in Nat :
        VRFHasValidKeys(validator) =>
            LET proof == VRFGenerateProof(validator, input)
            IN VRFVerifyValidatorProof(validator, proof)

\* VRF Pseudorandomness: Output distribution is uniform
VRFPseudorandomnessProperty ==
    \A validator \in ValidatorId :
        VRFHasValidKeys(validator) =>
            \A input \in Nat :
                LET proof == VRFGenerateProof(validator, input)
                IN /\ proof.output >= 0
                   /\ proof.output < MaxVRFOutput

----------------------------------------------------------------------------
(* Leader Selection with VRF *)

\* Compute VRF-based leader for a slot
VRFComputeLeader(slot, validators, stakeMap) ==
    IF validators = {} THEN 0
    ELSE LET totalStake == TotalStake(validators, stakeMap)
             \* Generate VRF proofs for all validators
             vrfProofs == {VRFGenerateProof(v, slot) : v \in validators}
             \* Filter valid proofs
             validProofs == {p \in vrfProofs : p.valid}
             \* Compute stake-weighted selection
             SelectLeaderFromProofs(proofs, stakes, total) ==
                 IF proofs = {} THEN 0
                 ELSE LET \* Find validator with smallest VRF output weighted by stake
                          WeightedValue(proof) == 
                              IF stakes[proof.validator] = 0 THEN MaxVRFOutput
                              ELSE (proof.output * total) \div stakes[proof.validator]
                          minWeighted == MinSet({WeightedValue(p) : p \in proofs})
                          winningProof == CHOOSE p \in proofs : WeightedValue(p) = minWeighted
                      IN winningProof.validator
         IN SelectLeaderFromProofs(validProofs, stakeMap, totalStake)

\* Alternative VRF leader selection using threshold
VRFComputeLeaderThreshold(slot, validators, stakeMap) ==
    IF validators = {} THEN 0
    ELSE LET totalStake == TotalStake(validators, stakeMap)
             \* Check each validator's VRF output against their stake threshold
             CheckLeaderEligibility(validator) ==
                 IF validator \in validators /\ VRFHasValidKeys(validator)
                 THEN LET proof == VRFGenerateProof(validator, slot)
                          stake == stakeMap[validator]
                          threshold == (stake * MaxVRFOutput) \div totalStake
                      IN /\ proof.valid
                         /\ proof.output < threshold
                 ELSE FALSE
             eligibleValidators == {v \in validators : CheckLeaderEligibility(v)}
         IN IF eligibleValidators = {} 
            THEN VRFComputeLeader(slot, validators, stakeMap)  \* Fallback
            ELSE CHOOSE v \in eligibleValidators : TRUE  \* Pick any eligible

\* Compute leader for a view within a leader window
VRFComputeLeaderForView(slot, view, validators, stakeMap, windowSize) ==
    LET windowStart == (slot \div windowSize) * windowSize
        viewInWindow == view % windowSize
        vrfInput == windowStart * 1000 + viewInWindow
    IN VRFComputeLeader(vrfInput, validators, stakeMap)

\* Verify leader selection is correct
VRFVerifyLeaderSelection(slot, leader, validators, stakeMap) ==
    /\ leader \in validators
    /\ VRFHasValidKeys(leader)
    /\ LET computedLeader == VRFComputeLeader(slot, validators, stakeMap)
       IN computedLeader = leader

\* Generate leader schedule for multiple slots
VRFGenerateLeaderSchedule(startSlot, endSlot, validators, stakeMap) ==
    [slot \in startSlot..endSlot |-> VRFComputeLeader(slot, validators, stakeMap)]

\* Verify leader schedule consistency
VRFVerifyLeaderSchedule(schedule, validators, stakeMap) ==
    \A slot \in DOMAIN schedule :
        VRFVerifyLeaderSelection(slot, schedule[slot], validators, stakeMap)

----------------------------------------------------------------------------
(* Leader Window Operations *)

\* Compute leader for 4-slot window
VRFComputeWindowLeader(windowIndex, validators, stakeMap) ==
    VRFComputeLeader(windowIndex, validators, stakeMap)

\* Rotate leader within window based on view
VRFRotateLeaderInWindow(windowLeader, view, validators, windowSize) ==
    IF windowLeader \notin validators THEN 0
    ELSE LET validatorList == CHOOSE seq \in Seq(validators) :
                                 /\ Len(seq) = Cardinality(validators)
                                 /\ \A v \in validators : \E i \in DOMAIN seq : seq[i] = v
                                 /\ \A i, j \in DOMAIN seq : i # j => seq[i] # seq[j]
             leaderIndex == CHOOSE i \in DOMAIN validatorList : validatorList[i] = windowLeader
             rotationOffset == view % windowSize
             newIndex == ((leaderIndex - 1 + rotationOffset) % Cardinality(validators)) + 1
         IN validatorList[newIndex]

\* Check if validator is leader for specific view in window
VRFIsLeaderForView(validator, slot, view, validators, stakeMap, windowSize) ==
    LET windowIndex == slot \div windowSize
        windowLeader == VRFComputeWindowLeader(windowIndex, validators, stakeMap)
        viewLeader == VRFRotateLeaderInWindow(windowLeader, view, validators, windowSize)
    IN viewLeader = validator

----------------------------------------------------------------------------
(* VRF State Management *)

\* Initialize VRF state
VRFInit ==
    /\ vrfProofs = {}
    /\ vrfOutputs = [v \in ValidatorId |-> 0]
    /\ leaderSchedule = [slot \in 1..100 |-> 0]  \* Initialize with empty schedule

\* Generate VRF proof action
VRFGenerateProofAction(validator, input) ==
    /\ VRFHasValidKeys(validator)
    /\ LET proof == VRFGenerateProof(validator, input)
       IN /\ vrfProofs' = vrfProofs \cup {proof}
          /\ vrfOutputs' = [vrfOutputs EXCEPT ![validator] = proof.output]
          /\ UNCHANGED leaderSchedule

\* Update leader schedule action
VRFUpdateLeaderSchedule(startSlot, endSlot, validators, stakeMap) ==
    /\ LET newSchedule == VRFGenerateLeaderSchedule(startSlot, endSlot, validators, stakeMap)
       IN leaderSchedule' = [slot \in DOMAIN leaderSchedule |->
                               IF slot \in startSlot..endSlot
                               THEN newSchedule[slot]
                               ELSE leaderSchedule[slot]]
    /\ UNCHANGED <<vrfProofs, vrfOutputs>>

\* VRF next state
VRFNext ==
    \/ \E validator \in ValidatorId, input \in Nat :
        VRFGenerateProofAction(validator, input)
    \/ \E start, end \in Nat, validators \in SUBSET ValidatorId, stakeMap \in [ValidatorId -> Nat] :
        VRFUpdateLeaderSchedule(start, end, validators, stakeMap)

----------------------------------------------------------------------------
(* VRF Invariants *)

\* All VRF proofs are valid
VRFProofsValid ==
    \A proof \in vrfProofs :
        /\ proof.valid
        /\ VRFVerifyValidatorProof(proof.validator, proof)

\* VRF outputs are consistent with proofs
VRFOutputsConsistent ==
    \A validator \in ValidatorId :
        \E proof \in vrfProofs :
            /\ proof.validator = validator
            /\ proof.output = vrfOutputs[validator]

\* Leader schedule is deterministic
VRFLeaderScheduleDeterministic ==
    \A slot \in DOMAIN leaderSchedule :
        leaderSchedule[slot] # 0 =>
            \E validators \in SUBSET ValidatorId, stakeMap \in [ValidatorId -> Nat] :
                leaderSchedule[slot] = VRFComputeLeader(slot, validators, stakeMap)

\* No validator can predict other validators' VRF outputs
VRFUnpredictability ==
    \A v1, v2 \in ValidatorId, input \in Nat :
        /\ v1 # v2
        /\ VRFHasValidKeys(v1)
        /\ VRFHasValidKeys(v2)
        => LET proof1 == VRFGenerateProof(v1, input)
               proof2 == VRFGenerateProof(v2, input)
           IN proof1.output # proof2.output

\* VRF maintains cryptographic properties
VRFCryptographicProperties ==
    /\ VRFUniquenessProperty
    /\ VRFUnpredictabilityProperty
    /\ VRFVerifiabilityProperty
    /\ VRFPseudorandomnessProperty

----------------------------------------------------------------------------
(* Integration with Consensus *)

\* Check if validator can propose in current view
VRFCanPropose(validator, slot, view, validators, stakeMap, windowSize) ==
    VRFIsLeaderForView(validator, slot, view, validators, stakeMap, windowSize)

\* Verify block proposer using VRF
VRFVerifyBlockProposer(block, validators, stakeMap, windowSize) ==
    VRFIsLeaderForView(block.proposer, block.slot, block.view, validators, stakeMap, windowSize)

\* Generate randomness for protocol decisions
VRFGenerateRandomness(slot, validators) ==
    LET vrfOutputs == {VRFGenerateProof(v, slot).output : v \in validators}
        combinedOutput == Hash(vrfOutputs)
    IN combinedOutput % MaxVRFOutput

\* Compute committee selection using VRF
VRFSelectCommittee(slot, validators, stakeMap, committeeSize) ==
    LET totalStake == TotalStake(validators, stakeMap)
        SelectMember(index) ==
            LET vrfInput == slot * 1000 + index
                vrfProofs == {VRFGenerateProof(v, vrfInput) : v \in validators}
                validProofs == {p \in vrfProofs : p.valid}
                WeightedValue(proof) == 
                    IF stakeMap[proof.validator] = 0 THEN MaxVRFOutput
                    ELSE (proof.output * totalStake) \div stakeMap[proof.validator]
                minWeighted == MinSet({WeightedValue(p) : p \in validProofs})
                winner == CHOOSE p \in validProofs : WeightedValue(p) = minWeighted
            IN winner.validator
        committee == {SelectMember(i) : i \in 1..committeeSize}
    IN committee

----------------------------------------------------------------------------
(* VRF Specification *)

VRFSpec ==
    /\ VRFInit
    /\ [][VRFNext]_<<vrfProofs, vrfOutputs, leaderSchedule>>

\* VRF Type Invariant
VRFTypeInvariant ==
    /\ vrfProofs \subseteq VRFProof
    /\ vrfOutputs \in [ValidatorId -> Nat]
    /\ leaderSchedule \in [Nat -> ValidatorId \cup {0}]

\* VRF Safety Properties
VRFSafetyProperties ==
    /\ VRFProofsValid
    /\ VRFOutputsConsistent
    /\ VRFLeaderScheduleDeterministic
    /\ VRFCryptographicProperties

\* VRF Liveness Properties
VRFLivenessProperties ==
    \* Eventually all validators generate VRF proofs
    /\ \A validator \in ValidatorId :
        VRFHasValidKeys(validator) =>
            <>(\E proof \in vrfProofs : proof.validator = validator)
    \* Leader schedule is eventually populated
    /\ <>(\A slot \in 1..10 : leaderSchedule[slot] # 0)

============================================================================