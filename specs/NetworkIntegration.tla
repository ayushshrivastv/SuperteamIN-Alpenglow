--------------------------- MODULE NetworkIntegration ---------------------------
(***************************************************************************)
(* Network Integration module for the Alpenglow consensus protocol.       *)
(* This module bridges the abstract network assumptions with the concrete  *)
(* protocol requirements, defining temporal properties that connect        *)
(* network message delivery with protocol progress.                       *)
(***************************************************************************)

EXTENDS Integers, Sequences, FiniteSets, TLC

CONSTANTS
    Validators,          \* Set of all validators
    ByzantineValidators, \* Set of Byzantine validators
    OfflineValidators,   \* Set of offline validators
    MaxSlot,             \* Maximum slot number
    MaxView,             \* Maximum view number
    MaxTime,             \* Maximum time value
    GST,                 \* Global Stabilization Time
    Delta,               \* Network delay bound after GST
    TotalStake,          \* Total stake in the system
    FastPathStake,       \* Stake threshold for fast path (80%)
    SlowPathStake        \* Stake threshold for slow path (60%)

ASSUME
    /\ ByzantineValidators \subseteq Validators
    /\ OfflineValidators \subseteq Validators
    /\ ByzantineValidators \cap OfflineValidators = {}
    /\ GST >= 0
    /\ Delta > 0
    /\ FastPathStake = (4 * TotalStake) \div 5  \* 80%
    /\ SlowPathStake = (3 * TotalStake) \div 5  \* 60%

HonestValidators == Validators \ (ByzantineValidators \cup OfflineValidators)
ResponsiveValidators == HonestValidators \ OfflineValidators

\* Import modules for type definitions
Types == INSTANCE Types

\* Declare variables that this module needs access to
\* These are shared with the main Alpenglow module
VARIABLES
    clock,                    \* Global clock
    messages,                 \* Network messages
    networkMessageBuffer,     \* Message buffers per validator
    networkDeliveryTime,      \* Message delivery times
    networkPartitions,        \* Current network partitions
    currentSlot,              \* Current slot number
    deliveredBlocks,          \* Set of delivered blocks
    finalizedBlocks,          \* Finalized blocks per slot
    votorGeneratedCerts       \* Certificates generated by Votor

----------------------------------------------------------------------------
(* Network Timing Model *)

\* Check if we are in the synchronous period (after GST)
InSynchronousPeriod == clock >= GST

\* Check if we are in the asynchronous period (before GST)
InAsynchronousPeriod == clock < GST

\* Message delivery deadline after GST
MessageDeliveryDeadline(msg) ==
    IF msg.timestamp >= GST
    THEN msg.timestamp + Delta
    ELSE GST + Delta  \* Messages sent before GST get GST + Delta deadline

\* Check if message delivery respects timing bounds
ValidMessageTiming(msg, deliveryTime) ==
    IF InSynchronousPeriod /\ msg.timestamp >= GST
    THEN deliveryTime <= MessageDeliveryDeadline(msg)
    ELSE TRUE  \* No constraints before GST

----------------------------------------------------------------------------
(* Partial Synchrony Properties *)

\* Partial synchrony assumption: bounded delays after GST
PartialSynchrony ==
    /\ InSynchronousPeriod
    => \A msg \in messages :
        msg.timestamp >= GST =>
            \E deliveryTime \in Nat :
                /\ deliveryTime <= msg.timestamp + Delta
                /\ <>(\E v \in Validators : msg \in networkMessageBuffer[v])

\* Message delay calculation
MessageDelay(msg) ==
    IF msg.id \in DOMAIN networkDeliveryTime
    THEN networkDeliveryTime[msg.id] - msg.timestamp
    ELSE 0  \* Not yet delivered

\* Message delivery guarantee after GST
MessageDeliveryAfterGST ==
    \A msg \in messages :
        /\ InSynchronousPeriod
        /\ msg.timestamp >= GST
        => <>(\E v \in Validators :
                msg \in networkMessageBuffer[v])

\* Add failureStates variable declaration
VARIABLE failureStates

\* Eventual delivery property for all messages using Network module definition
EventualDelivery ==
    \A msg \in messages :
        /\ msg.sender \in HonestValidators
        /\ msg.recipient \in HonestValidators \cup {"broadcast"}
        /\ failureStates[msg.sender] = "active"
        /\ (msg.recipient = "broadcast" \/ failureStates[msg.recipient] = "active")
        /\ clock >= GST
        => <>(\E v \in Validators :
                /\ (msg.recipient = "broadcast" => v \in HonestValidators)
                /\ (msg.recipient # "broadcast" => v = msg.recipient)
                /\ msg \in networkMessageBuffer[v]
                /\ Network!EventualDelivery(msg, clock))

\* All messages eventually delivered (global property)
AllMessagesDelivered ==
    clock >= GST =>
        <>(\A msg \in messages :
            /\ msg.sender \in HonestValidators
            /\ (msg.recipient \in HonestValidators \cup {"broadcast"})
            /\ failureStates[msg.sender] = "active"
            /\ (msg.recipient = "broadcast" \/ failureStates[msg.recipient] = "active")
            => (\E v \in Validators :
                    /\ (msg.recipient = "broadcast" => v \in HonestValidators)
                    /\ (msg.recipient # "broadcast" => v = msg.recipient)
                    /\ msg \in networkMessageBuffer[v]
                    /\ Network!CanDeliver(msg, clock)))

\* Bounded delay property after GST
BoundedDelayAfterGST ==
    clock >= GST =>
        \A msg \in messages :
            /\ msg.sender \in HonestValidators
            /\ msg.recipient \in HonestValidators
            /\ msg.timestamp >= GST
            /\ Network!MessageDeliveryAfterGST(msg, msg.timestamp, clock)
            => <>(\E v \in HonestValidators :
                    /\ v = msg.recipient
                    /\ msg \in networkMessageBuffer[v]
                    /\ clock <= msg.timestamp + Delta)

\* Network eventually becomes synchronous
EventualSynchrony ==
    <>(clock >= GST /\ PartialSynchrony)

----------------------------------------------------------------------------
(* Message Delivery Properties *)

\* All honest validators eventually receive broadcast messages after GST
BroadcastDelivery ==
    \A msg \in messages :
        /\ msg.recipient = "broadcast"
        /\ msg.sender \in HonestValidators
        /\ InSynchronousPeriod
        /\ msg.timestamp >= GST
        => <>(\A v \in HonestValidators :
                /\ failureStates[v] = "active"
                => msg \in networkMessageBuffer[v])

\* Point-to-point message delivery
UnicastDelivery ==
    \A msg \in messages :
        /\ msg.recipient \in Validators
        /\ msg.sender \in HonestValidators
        /\ InSynchronousPeriod
        /\ msg.timestamp >= GST
        /\ failureStates[msg.recipient] = "active"
        => <>(msg \in networkMessageBuffer[msg.recipient])

\* Message ordering preservation for honest senders
MessageOrdering ==
    \A msg1, msg2 \in messages :
        /\ msg1.sender = msg2.sender
        /\ msg1.sender \in HonestValidators
        /\ msg1.recipient = msg2.recipient
        /\ msg1.timestamp < msg2.timestamp
        /\ InSynchronousPeriod
        => \A u \in Validators :
            (msg1 \in networkMessageBuffer[u] /\ msg2 \in networkMessageBuffer[u])
            => \E t1, t2 \in Nat :
                t1 < t2 /\
                (msg1 \in networkMessageBuffer[u] /\ clock = t1) /\
                (msg2 \in networkMessageBuffer[u] /\ clock = t2)

----------------------------------------------------------------------------
(* Network Partition Handling *)

\* Network partition detection
PartitionDetected ==
    networkPartitions # {}

\* Partition recovery condition
PartitionRecovery ==
    /\ PartitionDetected
    /\ clock >= GST + Delta
    => <>(\A partition \in networkPartitions :
            LET partitionStake == Types!TotalStake(partition, [v \in Validators |-> TotalStake \div Cardinality(Validators)])
            IN partitionStake <= TotalStake \div 2)  \* No majority partition

\* Network healing after partition
NetworkHealing ==
    /\ PartitionDetected
    => <>(networkPartitions = {} /\
          \A v1, v2 \in HonestValidators :
            \A msg \in messages :
                /\ msg.sender = v1
                /\ msg.recipient = v2
                /\ msg.timestamp >= clock
                => <>(msg \in networkMessageBuffer[v2]))

\* Partition resilience: progress resumes after healing
PartitionResilience ==
    /\ NetworkHealing
    /\ clock >= GST + 2 * Delta
    => <>(\E block \in finalizedBlocks[currentSlot] : TRUE)

----------------------------------------------------------------------------
(* Integration with Protocol Progress *)

\* Block propagation timing
BlockPropagationTiming ==
    \A block \in deliveredBlocks :
        /\ block.slot = currentSlot
        /\ InSynchronousPeriod
        => \A v \in ResponsiveValidators :
            <>(\E msg \in networkMessageBuffer[v] :
                /\ msg.type = "block"
                /\ msg.payload = block.hash)

\* Vote collection timing
VoteCollectionTiming ==
    \A v \in ResponsiveValidators :
        \A block \in deliveredBlocks :
            /\ block.slot = currentSlot
            /\ InSynchronousPeriod
            /\ failureStates[v] = "active"
            => <>(\E vote_msg \in networkMessageBuffer[v] :
                    /\ vote_msg.type = "vote"
                    /\ vote_msg.sender = v)

\* Certificate propagation timing
CertificatePropagationTiming ==
    \A vw \in 1..MaxView :
        \A cert \in votorGeneratedCerts[vw] :
            /\ cert.slot = currentSlot
            /\ InSynchronousPeriod
            => \A v \in ResponsiveValidators :
                <>(\E cert_msg \in networkMessageBuffer[v] :
                    /\ cert_msg.type = "certificate"
                    /\ cert_msg.payload = cert)

\* Protocol delay tolerance bounds
ProtocolDelayTolerance ==
    /\ \A msg \in messages :
        /\ msg.sender \in HonestValidators
        /\ InSynchronousPeriod
        /\ msg.timestamp >= GST
        /\ Network!BoundedDelayAfterGST(msg.timestamp, clock)
        => MessageDelay(msg) <= 2 * Delta  \* Protocol can tolerate up to 2*Delta delay
    /\ \A slot \in 1..MaxSlot :
        \A block \in deliveredBlocks :
            /\ block.slot = slot
            /\ InSynchronousPeriod
            => \E finalTime \in Nat :
                /\ finalTime <= block.timestamp + 3 * Delta  \* Block finalization within 3*Delta
                /\ \E finalizedBlock \in finalizedBlocks[slot] :
                    finalizedBlock.hash = block.hash

\* End-to-end finalization timing
FinalizationTiming ==
    \A block \in deliveredBlocks :
        /\ block.slot = currentSlot
        /\ InSynchronousPeriod
        /\ Types!TotalStake(ResponsiveValidators, [v \in Validators |-> TotalStake \div Cardinality(Validators)]) >= SlowPathStake
        => <>(\E finalizedBlock \in finalizedBlocks[currentSlot] :
                finalizedBlock.hash = block.hash)

----------------------------------------------------------------------------
(* Network Invariants *)

\* Message integrity: honest validators don't forge messages
MessageIntegrity ==
    \A msg \in messages :
        /\ msg.sender \in HonestValidators
        => /\ msg.signature.signer = msg.sender
           /\ msg.signature.valid = TRUE
           /\ Types!NoSignatureForge(msg.signature, msg.sender, HonestValidators)

\* Message authenticity: delivered messages are authentic
MessageAuthenticity ==
    \A v \in Validators :
        \A msg \in networkMessageBuffer[v] :
            /\ msg.sender \in HonestValidators
            => msg.signature.valid /\ msg.signature.signer = msg.sender

\* Network capacity constraints
NetworkCapacityConstraint ==
    Cardinality(messages) <= 1000 * Cardinality(Validators)  \* Bounded message pool

\* Delivery time consistency
DeliveryTimeConsistency ==
    \A msg \in messages :
        \A v \in Validators :
            msg \in networkMessageBuffer[v] =>
                /\ msg.id \in DOMAIN networkDeliveryTime
                /\ ValidMessageTiming(msg, networkDeliveryTime[msg.id])

----------------------------------------------------------------------------
(* Liveness Integration Properties *)

\* Progress depends on network delivery
NetworkDependentProgress ==
    /\ InSynchronousPeriod
    /\ BroadcastDelivery
    /\ VoteCollectionTiming
    => <>(\E cert \in UNION {votorGeneratedCerts[vw] : vw \in 1..MaxView} :
            cert.slot = currentSlot)

\* Fast path requires responsive network
FastPathNetworkRequirement ==
    /\ InSynchronousPeriod
    /\ Types!TotalStake(ResponsiveValidators, [v \in Validators |-> TotalStake \div Cardinality(Validators)]) >= FastPathStake
    /\ \A msg \in messages :
        msg.timestamp >= GST =>
            <>(\E v \in ResponsiveValidators :
                msg \in networkMessageBuffer[v])
    => <>(\E cert \in UNION {votorGeneratedCerts[vw] : vw \in 1..MaxView} :
            /\ cert.slot = currentSlot
            /\ cert.type = "fast")

\* Slow path network tolerance
SlowPathNetworkTolerance ==
    /\ InSynchronousPeriod
    /\ Types!TotalStake(ResponsiveValidators, [v \in Validators |-> TotalStake \div Cardinality(Validators)]) >= SlowPathStake
    /\ \A msg \in messages :
        msg.timestamp >= GST =>
            <>(\E v \in ResponsiveValidators :
                msg \in networkMessageBuffer[v])
    => <>(\E cert \in UNION {votorGeneratedCerts[vw] : vw \in 1..MaxView} :
            /\ cert.slot = currentSlot
            /\ cert.type \in {"slow", "fast"})

----------------------------------------------------------------------------
(* Safety Integration Properties *)

\* Network cannot cause safety violations
NetworkSafetyPreservation ==
    /\ MessageIntegrity
    /\ MessageAuthenticity
    => \A slot \in 1..MaxSlot :
        Cardinality(finalizedBlocks[slot]) <= 1

\* Byzantine network behavior is bounded
ByzantineNetworkBehavior ==
    LET byzantineMessages == {msg \in messages : msg.sender \in ByzantineValidators}
    IN Cardinality(byzantineMessages) <=
       Cardinality(ByzantineValidators) * 10 * currentSlot  \* Bounded Byzantine message rate

\* Partition safety: no conflicting decisions across partitions
PartitionSafety ==
    \A partition1, partition2 \in networkPartitions :
        partition1 # partition2 =>
            \A slot \in 1..MaxSlot :
                \A v1 \in partition1, v2 \in partition2 :
                    \A b1 \in finalizedBlocks[slot], b2 \in finalizedBlocks[slot] :
                        b1 = b2

----------------------------------------------------------------------------
(* Main Integration Theorems *)

\* Enhanced network timing properties that integrate all delivery guarantees
EnhancedNetworkTiming ==
    /\ PartialSynchrony
    /\ EventualDelivery
    /\ AllMessagesDelivered
    /\ ProtocolDelayTolerance
    /\ BoundedDelayAfterGST

\* Network integration preserves safety
THEOREM NetworkSafetyIntegration ==
    ASSUME
        /\ Types!TotalStake(ByzantineValidators, [v \in Validators |-> TotalStake \div Cardinality(Validators)]) < TotalStake \div 3
        /\ MessageIntegrity
        /\ MessageAuthenticity
    PROVE
        NetworkSafetyPreservation
PROOF
    <1>1. \A msg \in messages : msg.sender \in HonestValidators =>
            msg.signature.valid /\ msg.signature.signer = msg.sender
          BY MessageIntegrity, MessageAuthenticity
    <1>2. \A slot \in 1..MaxSlot :
            \A cert1, cert2 \in UNION {votorGeneratedCerts[vw] : vw \in 1..MaxView} :
                /\ cert1.slot = slot
                /\ cert2.slot = slot
                => cert1.block = cert2.block
          BY <1>1, Types!TotalStake(ByzantineValidators, [v \in Validators |-> TotalStake \div Cardinality(Validators)]) < TotalStake \div 3
    <1>3. NetworkSafetyPreservation
          BY <1>2 DEF NetworkSafetyPreservation, finalizedBlocks
    <1>4. QED
          BY <1>3

\* Network integration enables liveness
THEOREM NetworkLivenessIntegration ==
    ASSUME
        /\ InSynchronousPeriod
        /\ BroadcastDelivery
        /\ VoteCollectionTiming
        /\ CertificatePropagationTiming
        /\ FinalizationTiming
        /\ EventualDelivery
        /\ AllMessagesDelivered
        /\ ProtocolDelayTolerance
        /\ Types!TotalStake(ResponsiveValidators, [v \in Validators |-> TotalStake \div Cardinality(Validators)]) >= SlowPathStake
        /\ clock >= GST + 3 * Delta
    PROVE
        <>(\E block \in finalizedBlocks[currentSlot] : TRUE)
PROOF
    <1>1. \A block \in deliveredBlocks : block.slot = currentSlot =>
            <>(\A v \in ResponsiveValidators :
                \E msg \in networkMessageBuffer[v] : msg.payload = block.hash)
          BY BroadcastDelivery, BlockPropagationTiming, EventualDelivery
    <1>2. <>(\A v \in ResponsiveValidators :
              \E vote_msg \in networkMessageBuffer[v] : vote_msg.type = "vote")
          BY <1>1, VoteCollectionTiming, AllMessagesDelivered
    <1>3. <>(\E cert \in UNION {votorGeneratedCerts[vw] : vw \in 1..MaxView} :
              cert.slot = currentSlot)
          BY <1>2, Types!TotalStake(ResponsiveValidators, [v \in Validators |-> TotalStake \div Cardinality(Validators)]) >= SlowPathStake
    <1>4. <>(\E block \in finalizedBlocks[currentSlot] : TRUE)
          BY <1>3, CertificatePropagationTiming, FinalizationTiming, ProtocolDelayTolerance
    <1>5. QED
          BY <1>4

\* Combined network integration theorem
THEOREM NetworkIntegrationMain ==
    ASSUME
        /\ Types!TotalStake(ByzantineValidators, [v \in Validators |-> TotalStake \div Cardinality(Validators)]) < TotalStake \div 3
        /\ MessageIntegrity
        /\ MessageAuthenticity
        /\ InSynchronousPeriod
        /\ BroadcastDelivery
        /\ VoteCollectionTiming
        /\ CertificatePropagationTiming
        /\ FinalizationTiming
        /\ EventualDelivery
        /\ AllMessagesDelivered
        /\ ProtocolDelayTolerance
        /\ Types!TotalStake(ResponsiveValidators, [v \in Validators |-> TotalStake \div Cardinality(Validators)]) >= SlowPathStake
    PROVE
        /\ NetworkSafetyPreservation  \* Safety is preserved
        /\ (clock >= GST + 3 * Delta => <>(\E block \in finalizedBlocks[currentSlot] : TRUE))  \* Liveness is achieved
PROOF
    <1>1. NetworkSafetyPreservation
          BY NetworkSafetyIntegration
    <1>2. clock >= GST + 3 * Delta => <>(\E block \in finalizedBlocks[currentSlot] : TRUE)
          BY NetworkLivenessIntegration
    <1>3. QED
          BY <1>1, <1>2

============================================================================
