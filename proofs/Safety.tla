---------------------------- MODULE Safety ----------------------------
(***************************************************************************)
(* Safety properties specification and machine-checked proofs for the     *)
(* Alpenglow consensus protocol, proving no conflicting blocks can be     *)
(* finalized in the same slot.                                           *)
(***************************************************************************)

EXTENDS Integers, FiniteSets, Sequences, TLAPS

\* Import main specification - provides all state variables
INSTANCE Alpenglow
INSTANCE Types
INSTANCE Utils
INSTANCE Votor
INSTANCE Rotor
INSTANCE VRF
INSTANCE EconomicModel

\* Define missing constants and assumptions
CONSTANTS CryptographicAssumptions
ASSUME CryptographicAssumptions \in BOOLEAN
ASSUME CryptographicAssumptions = TRUE

\* Local helper definitions to resolve symbol mismatches and missing ops
\* Certificates is the union of all certificates generated by votors across views
Certificates ==
    UNION { votorGeneratedCerts[vw] : vw \in 1..MaxView }

\* Calculate total stake for a set of validators
StakeOfSet(validatorSet) ==
    Utils!Sum([v \in validatorSet |-> Stake[v]])

\* Total stake in the system (fix undefined StakeOfSetSum reference)
TotalStakeSum == StakeOfSet(Validators)
StakeOfSetSum == TotalStakeSum  \* Alias for compatibility

\* Define required stake per certificate type (fast/slow)
RequiredStake(type) ==
    IF type = "fast" THEN (4 * TotalStakeSum) \div 5
    ELSE IF type = "slow" THEN (3 * TotalStakeSum) \div 5
    ELSE 0

\* Compute total stake of a certificate from its validators set
CertStake(cert) ==
    cert.stake  \* Use the stake field from Types!Certificate

\* Predicates for certificate types based on stake held by their validators
FastCertificate(cert) ==
    CertStake(cert) >= RequiredStake("fast")

SlowCertificate(cert) ==
    CertStake(cert) >= RequiredStake("slow")

\* Simple assumption definition about Byzantine stake bound used by proofs
ByzantineAssumption ==
    Utils!Sum([v \in ByzantineValidators |-> Stake[v]]) <= TotalStakeSum \div 5

\* Leader window size constant for VRF-based selection
LeaderWindowSize == 4

\* VRF-based leader selection determinism
VRFLeaderDeterminism ==
    \A slot \in 1..MaxSlot, validators \in SUBSET Validators, stakeMap \in [Validators -> Nat] :
        LET leader1 == VRF!VRFComputeLeader(slot, validators, stakeMap)
            leader2 == VRF!VRFComputeLeader(slot, validators, stakeMap)
        IN leader1 = leader2

----------------------------------------------------------------------------
(* Helper Lemmas - Defined Before Use *)

\* Cryptographic integrity ensures honest validators cannot equivocate
LEMMA CryptographicIntegrity ==
    \A v \in (Validators \ ByzantineValidators) :
        \A shred1, shred2 \in UNION {Rotor!blockShreds[b][v] : b \in DOMAIN Rotor!blockShreds} :
            /\ shred1.slot = shred2.slot
            /\ shred1.index = shred2.index
            => shred1 = shred2
PROOF
    <1>1. Honest validators use cryptographic signatures
        BY DEF Types!Shred, Crypto!Sign
    <1>2. Cryptographic signatures prevent forgery
        BY CryptographicAssumptions
    <1>3. Same slot and index with honest validator implies same shred
        BY <1>1, <1>2
    <1> QED BY <1>3

\* Certificate uniqueness lemma
LEMMA CertificateUniquenessLemma ==
    /\ EconomicModel!SlashingCorrectness
    /\ VRFLeaderSelectionDeterminism
    => []CertificateUniqueness
PROOF
    <1>1. Init => CertificateUniqueness
        BY DEF Init, CertificateUniqueness

    <1>2. CertificateUniqueness /\ Next => CertificateUniqueness'
        <2>1. ASSUME CertificateUniqueness,
                     \E v \in Validators : VotorAction
              PROVE CertificateUniqueness'
            <3>1. SUFFICES ASSUME NEW c1 \in Certificates',
                                  NEW c2 \in Certificates',
                                  c1.type = c2.type,
                                  c1.slot = c2.slot,
                                  c1.block # {},
                                  c2.block # {}
                           PROVE c1.block = c2.block
                BY DEF CertificateUniqueness

            <3>2. CASE c1 \in Certificates /\ c2 \in Certificates
                BY <3>2, CertificateUniqueness

            <3>3. CASE c1 \notin Certificates \/ c2 \notin Certificates
                <4>1. c1.stake >= RequiredStake(c1.type)
                    BY DEF RequiredStake
                <4>2. c2.stake >= RequiredStake(c2.type)
                    BY DEF RequiredStake
                <4>3. c1.type = c2.type => RequiredStake(c1.type) = RequiredStake(c2.type)
                    BY DEF RequiredStake
                <4>4. Economic slashing reduces effective Byzantine stake
                    BY EconomicModel!SlashingCorrectness, EconomicModel!SlashingBounds
                <4>5. LET effectiveByzantineStake == StakeOfSet(ByzantineValidators) -
                                                    Utils!Sum([v \in ByzantineValidators |-> EconomicModel!slashedStake[v]])
                      IN effectiveByzantineStake < TotalStakeSum \div 5
                    BY <4>4, EconomicModel!TokenConservation
                <4>6. TotalStake - effectiveByzantineStake < 2 * RequiredStake(c1.type)
                    BY <4>5, <4>3
                <4>7. VRF-based leader selection ensures unique proposer
                    BY VRFLeaderSelectionDeterminism, VRFLeaderWindowConsistency
                <4>8. LET V1 == {v \in Validators : \E sig \in c1.signatures.sigs : sig.validator = v}
                          V2 == {v \in Validators : \E sig \in c2.signatures.sigs : sig.validator = v}
                      IN V1 \cap V2 # {}
                    BY <4>1, <4>2, <4>6, PigeonholePrinciple
                <4>9. \E v \in Validators :
                        /\ (\E sig \in c1.signatures.sigs : sig.validator = v)
                        /\ (\E sig \in c2.signatures.sigs : sig.validator = v)
                        /\ v \notin ByzantineValidators
                        /\ EconomicModel!slashedStake[v] = 0  \* Not slashed
                    BY <4>8, HonestMajorityAssumption, <4>5
                <4>10. c1.block = c2.block
                    BY <4>9, HonestSingleVote, <4>7
                <4> QED BY <4>10, <3>3

            <3> QED BY <3>2, <3>3

        <2> QED BY <2>1 DEF Next

    <1> QED BY <1>1, <1>2, PTL

\* Pigeonhole principle for validator sets
LEMMA PigeonholePrinciple ==
    \A S1, S2 \in SUBSET Validators :
        StakeOfSet(S1) + StakeOfSet(S2) > TotalStakeSum =>
            S1 \cap S2 # {}
PROOF
    <1>1. SUFFICES ASSUME NEW S1 \in SUBSET Validators,
                          NEW S2 \in SUBSET Validators,
                          StakeOfSet(S1) + StakeOfSet(S2) > TotalStakeSum
                   PROVE S1 \cap S2 # {}
        BY DEF PigeonholePrinciple
    <1>2. ASSUME S1 \cap S2 = {}
          PROVE StakeOfSet(S1 \cup S2) = StakeOfSet(S1) + StakeOfSet(S2)
        BY <1>2 DEF StakeOfSet
    <1>3. S1 \cup S2 \subseteq Validators
        BY <1>1
    <1>4. StakeOfSet(S1 \cup S2) <= TotalStakeSum
        BY <1>3 DEF TotalStakeSum, StakeOfSet
    <1>5. StakeOfSet(S1) + StakeOfSet(S2) <= TotalStakeSum
        BY <1>2, <1>4
    <1>6. FALSE
        BY <1>1, <1>5
    <1> QED BY <1>6

\* Honest majority assumption
LEMMA HonestMajorityAssumption ==
    StakeOfSet(Validators \ ByzantineValidators) > StakeOfSet(ByzantineValidators)
PROOF
    <1>1. StakeOfSet(ByzantineValidators) <= TotalStakeSum \div 5
        BY ByzantineAssumption

    <1>2. StakeOfSet(Validators \ ByzantineValidators) =
          TotalStakeSum - StakeOfSet(ByzantineValidators)
        BY DEF StakeOfSet, TotalStakeSum

    <1>3. TotalStakeSum - TotalStakeSum \div 5 = (4 * TotalStakeSum) \div 5
        BY SimpleArithmetic

    <1>4. StakeOfSet(Validators \ ByzantineValidators) >= (4 * TotalStakeSum) \div 5
        BY <1>1, <1>2, <1>3

    <1>5. (4 * TotalStakeSum) \div 5 > TotalStakeSum \div 5
        BY TotalStakeSum > 0

    <1> QED BY <1>1, <1>4, <1>5

\* Simple arithmetic lemma
LEMMA SimpleArithmetic ==
    /\ \A x \in Nat : x > 0 => 4 * x > x
    /\ \A x \in Nat : x - x \div 5 = (4 * x) \div 5
    /\ \A x, y \in Nat : x > y => x >= y
PROOF
    BY DEF Nat

----------------------------------------------------------------------------
(* Rotor Non-Equivocation Theorem *)

\* Rotor non-equivocation follows from honest validator behavior and cryptographic assumptions
THEOREM RotorNonEquivocationTheorem ==
    /\ \A v \in (Validators \ ByzantineValidators) :
        \A shredId \in Rotor!ShredId :
            Rotor!HasSentShred(v, shredId) =>
                \A otherShred \in UNION {Rotor!blockShreds[b][v] : b \in DOMAIN Rotor!blockShreds} :
                    (otherShred.slot = shredId.slot /\ otherShred.index = shredId.index) =>
                    otherShred = Rotor!GetSentShred(v, shredId)
    /\ Rotor!RotorNonEquivocation
PROOF
    <1>1. \A v \in (Validators \ ByzantineValidators) :
          \A shredId \in Rotor!ShredId :
              Rotor!HasSentShred(v, shredId) =>
                  LET sentShred == Rotor!GetSentShred(v, shredId)
                  IN \A otherShred \in UNION {Rotor!blockShreds[b][v] : b \in DOMAIN Rotor!blockShreds} :
                      (otherShred.slot = shredId.slot /\ otherShred.index = shredId.index) =>
                      otherShred = sentShred
        <2>1. SUFFICES ASSUME NEW v \in (Validators \ ByzantineValidators),
                              NEW shredId \in Rotor!ShredId,
                              Rotor!HasSentShred(v, shredId),
                              NEW otherShred \in UNION {Rotor!blockShreds[b][v] : b \in DOMAIN Rotor!blockShreds},
                              otherShred.slot = shredId.slot,
                              otherShred.index = shredId.index
                       PROVE otherShred = Rotor!GetSentShred(v, shredId)
            OBVIOUS
        <2>2. v \notin ByzantineValidators => v follows honest protocol
            BY DEF ByzantineValidators
        <2>3. Honest validators record shreds consistently in rotorHistory
            BY <2>2 DEF Rotor!RecordShredSent, Rotor!ShredAndDistribute, Rotor!RelayShreds
        <2>4. Rotor!rotorHistory[v][shredId] = Rotor!GetSentShred(v, shredId)
            BY <2>3 DEF Rotor!GetSentShred, Rotor!HasSentShred
        <2>5. otherShred = Rotor!rotorHistory[v][shredId]
            BY <2>1, <2>3, <2>4, CryptographicIntegrity
        <2> QED BY <2>4, <2>5

    <1>2. Rotor!RotorNonEquivocation
        BY <1>1 DEF Rotor!RotorNonEquivocation

    <1> QED BY <1>1, <1>2

----------------------------------------------------------------------------
(* VRF Uniqueness and Determinism Lemmas *)

LEMMA VRFUniquenessLemma ==
    \A validator \in Validators, input \in Nat :
        VRF!VRFHasValidKeys(validator) =>
            LET proof1 == VRF!VRFGenerateProof(validator, input)
                proof2 == VRF!VRFGenerateProof(validator, input)
            IN proof1.output = proof2.output
PROOF
    <1>1. SUFFICES ASSUME NEW validator \in Validators,
                          NEW input \in Nat,
                          VRF!VRFHasValidKeys(validator)
                   PROVE LET proof1 == VRF!VRFGenerateProof(validator, input)
                             proof2 == VRF!VRFGenerateProof(validator, input)
                         IN proof1.output = proof2.output
        OBVIOUS
    <1>2. VRF!VRFUniquenessProperty
        BY DEF VRF!VRFUniquenessProperty
    <1> QED BY <1>2

LEMMA VRFLeaderSelectionDeterminism ==
    \A slot \in 1..MaxSlot, validators \in SUBSET Validators, stakeMap \in [Validators -> Nat] :
        LET leader1 == VRF!VRFComputeLeader(slot, validators, stakeMap)
            leader2 == VRF!VRFComputeLeader(slot, validators, stakeMap)
        IN leader1 = leader2
PROOF
    <1>1. SUFFICES ASSUME NEW slot \in 1..MaxSlot,
                          NEW validators \in SUBSET Validators,
                          NEW stakeMap \in [Validators -> Nat]
                   PROVE LET leader1 == VRF!VRFComputeLeader(slot, validators, stakeMap)
                             leader2 == VRF!VRFComputeLeader(slot, validators, stakeMap)
                         IN leader1 = leader2
        OBVIOUS
    <1>2. VRF!VRFComputeLeader is deterministic function
        BY DEF VRF!VRFComputeLeader, VRF!VRFGenerateProof, VRF!VRFEvaluate
    <1> QED BY <1>2

LEMMA VRFLeaderWindowConsistency ==
    \A slot \in 1..MaxSlot, view \in 1..MaxView, validators \in SUBSET Validators, stakeMap \in [Validators -> Nat] :
        LET windowIndex == slot \div LeaderWindowSize
            leader1 == VRF!VRFComputeWindowLeader(windowIndex, validators, stakeMap)
            isLeaderForView == VRF!VRFIsLeaderForView(leader1, slot, view, validators, stakeMap, LeaderWindowSize)
            rotatedLeader == VRF!VRFRotateLeaderInWindow(leader1, view, validators, LeaderWindowSize)
        IN isLeaderForView \/ (rotatedLeader \in validators)
PROOF
    <1>1. VRF!VRFComputeWindowLeader produces valid leader
        BY DEF VRF!VRFComputeWindowLeader, VRF!VRFComputeLeader
    <1>2. VRF!VRFRotateLeaderInWindow maintains validator set membership
        BY DEF VRF!VRFRotateLeaderInWindow
    <1> QED BY <1>1, <1>2

----------------------------------------------------------------------------
(* Core Safety Invariant *)

\* No two conflicting blocks finalized in same slot
SafetyInvariant ==
    \A slot \in 1..MaxSlot :
        \A b1, b2 \in finalizedBlocks[slot] :
            b1 = b2

THEOREM SafetyTheorem ==
    /\ RotorNonEquivocationTheorem
    /\ VRFLeaderSelectionDeterminism
    /\ EconomicModel!SlashingCorrectness
    => (Spec => []SafetyInvariant)
PROOF
    <1>1. Init => SafetyInvariant
        BY DEF Init, SafetyInvariant

    <1>2. SafetyInvariant /\ Next => SafetyInvariant'
        <2>1. ASSUME SafetyInvariant,
                     VotorAction
              PROVE SafetyInvariant'
            <3>1. CASE \E v \in Validators : Votor!CastVote(v)
                <4>1. VRF-based leader selection ensures unique proposer per view
                    BY VRFLeaderSelectionDeterminism, VRFLeaderWindowConsistency
                <4>2. Economic slashing prevents Byzantine behavior
                    BY EconomicModel!SlashingCorrectness, EconomicModel!SlashingBounds
                <4>3. finalizedBlocks' = finalizedBlocks \/ NewlyFinalizedBlocks
                    BY DEF Votor!CastVote, Votor!GenerateCertificate
                <4>4. NewlyFinalizedBlocks satisfies SafetyInvariant
                    BY <4>1, <4>2, CertificateUniquenessLemma
                <4> QED BY <4>3, <4>4

            <3>2. CASE \E v \in Validators : Rotor!ShredAndDistribute(v, block)
                <4>1. Rotor non-equivocation maintained
                    BY RotorNonEquivocationTheorem
                <4>2. No new finalizations from shredding
                    BY DEF Rotor!ShredAndDistribute
                <4>3. finalizedBlocks' = finalizedBlocks
                    BY <4>2
                <4> QED BY <4>3, SafetyInvariant

            <3>3. CASE \E v \in Validators, amount \in Nat, reason \in STRING :
                       EconomicModel!SlashValidator(v, amount, reason)
                <4>1. Slashing removes Byzantine stake
                    BY DEF EconomicModel!SlashValidator, EconomicModel!SlashingAmount
                <4>2. Reduced Byzantine stake strengthens safety
                    BY <4>1, ByzantineResilienceTheorem
                <4>3. finalizedBlocks unchanged by slashing
                    BY DEF EconomicModel!SlashValidator
                <4> QED BY <4>3, SafetyInvariant

            <3> QED BY <3>1, <3>2, <3>3 DEF VotorAction, Next

        <2>2. ASSUME SafetyInvariant,
                     ~VotorAction
              PROVE SafetyInvariant'
            BY <2>2 DEF SafetyInvariant, Next

        <2> QED BY <2>1, <2>2 DEF Next

    <1> QED BY <1>1, <1>2, PTL DEF Spec

----------------------------------------------------------------------------
(* Certificate Uniqueness *)

\* At most one certificate per slot and type, considering economic slashing
CertificateUniqueness ==
    \A c1, c2 \in Certificates :
        /\ c1.type = c2.type
        /\ c1.slot = c2.slot  \* Use slot field directly
        /\ c1.block # {}
        /\ c2.block # {}
        => c1.block = c2.block

LEMMA CertificateUniquenessLemma ==
    /\ EconomicModel!SlashingCorrectness
    /\ VRFLeaderSelectionDeterminism
    => []CertificateUniqueness
PROOF
    <1>1. Init => CertificateUniqueness
        BY DEF Init, CertificateUniqueness

    <1>2. CertificateUniqueness /\ Next => CertificateUniqueness'
        <2>1. ASSUME CertificateUniqueness,
                     \E v \in Validators : VotorAction
              PROVE CertificateUniqueness'
            <3>1. SUFFICES ASSUME NEW c1 \in Certificates',
                                  NEW c2 \in Certificates',
                                  c1.type = c2.type,
                                  c1.slot = c2.slot,
                                  c1.block # {},
                                  c2.block # {}
                           PROVE c1.block = c2.block
                BY DEF CertificateUniqueness

            <3>2. CASE c1 \in Certificates /\ c2 \in Certificates
                BY <3>2, CertificateUniqueness

            <3>3. CASE c1 \notin Certificates \/ c2 \notin Certificates
                <4>1. c1.stake >= RequiredStake(c1.type)
                    BY DEF RequiredStake
                <4>2. c2.stake >= RequiredStake(c2.type)
                    BY DEF RequiredStake
                <4>3. c1.type = c2.type => RequiredStake(c1.type) = RequiredStake(c2.type)
                    BY DEF RequiredStake
                <4>4. Economic slashing reduces effective Byzantine stake
                    BY EconomicModel!SlashingCorrectness, EconomicModel!SlashingBounds
                <4>5. LET effectiveByzantineStake == StakeOfSet(ByzantineValidators) -
                                                    Utils!Sum([v \in ByzantineValidators |-> EconomicModel!slashedStake[v]])
                      IN effectiveByzantineStake < TotalStakeSum \div 5
                    BY <4>4, EconomicModel!TokenConservation
                <4>6. TotalStake - effectiveByzantineStake < 2 * RequiredStake(c1.type)
                    BY <4>5, <4>3
                <4>7. VRF-based leader selection ensures unique proposer
                    BY VRFLeaderSelectionDeterminism, VRFLeaderWindowConsistency
                <4>8. LET V1 == {v \in Validators : \E sig \in c1.signatures.sigs : sig.validator = v}
                          V2 == {v \in Validators : \E sig \in c2.signatures.sigs : sig.validator = v}
                      IN V1 \cap V2 # {}
                    BY <4>1, <4>2, <4>6, PigeonholePrinciple
                <4>9. \E v \in Validators :
                        /\ (\E sig \in c1.signatures.sigs : sig.validator = v)
                        /\ (\E sig \in c2.signatures.sigs : sig.validator = v)
                        /\ v \notin ByzantineValidators
                        /\ EconomicModel!slashedStake[v] = 0  \* Not slashed
                    BY <4>8, HonestMajorityAssumption, <4>5
                <4>10. c1.block = c2.block
                    BY <4>9, HonestSingleVote, <4>7
                <4> QED BY <4>10, <3>3

            <3> QED BY <3>2, <3>3

        <2> QED BY <2>1 DEF Next

    <1> QED BY <1>1, <1>2, PTL

----------------------------------------------------------------------------
(* Non-Equivocation Properties *)

\* Honest validators vote at most once per view
HonestSingleVote ==
    \A v \in (Validators \\ (ByzantineValidators \cup OfflineValidators)) :
        \A view \in 1..MaxView :
            \A vote1, vote2 \in Votor!votes :
                (vote1.validator = v /\ vote1.view = view /\
                 vote2.validator = v /\ vote2.view = view) => vote1 = vote2

THEOREM HonestSingleVoteTheorem ==
    Spec => []HonestSingleVote
PROOF
    <1>1. Init => HonestSingleVote
        BY DEF Init, HonestSingleVote

    <1>2. HonestSingleVote /\ Next => HonestSingleVote'
        <2>1. ASSUME HonestSingleVote,
                     VotorAction,
                     v \in (Validators \ (ByzantineValidators \cup OfflineValidators))
              PROVE HonestSingleVote'
            BY <2>1 DEF HonestSingleVote, VotorAction

        <2> QED BY <2>1 DEF Next

    <1> QED BY <1>1, <1>2, PTL DEF Spec

\* Byzantine validators cannot break safety even with double voting, considering economic slashing
ByzantineDoubleVoteBounded ==
    \A view \in 1..MaxView :
        LET byzantineVotes == {vote \in votes :
                                vote.sender \in ByzantineValidators /\ vote.view = view}
            effectiveByzantineStake == StakeOfSet({vote.sender : vote \in byzantineVotes}) -
                                     Utils!Sum([v \in {vote.sender : vote \in byzantineVotes} |-> EconomicModel!slashedStake[v]])
        IN effectiveByzantineStake <= (ByzantineFaultBound * TotalStakeSum) \div 100

LEMMA ByzantineCannotForceCertificate ==
    /\ EconomicModel!SlashingCorrectness
    /\ VRFLeaderSelectionDeterminism
    => \A view \in 1..MaxView :
        \A block \in DOMAIN votorVotedBlocks[Validators] :
            LET effectiveByzantineStake == StakeOfSet(ByzantineValidators) -
                                         Utils!Sum([v \in ByzantineValidators |-> EconomicModel!slashedStake[v]])
            IN effectiveByzantineStake < (3 * TotalStakeSum) \div 5 =>
                ~(\E cert \in Certificates : cert.votes \subseteq ByzantineValidators)
PROOF
    <1>1. Economic slashing reduces Byzantine voting power
        BY DEF EconomicModel!SlashValidator, EconomicModel!SlashingAmount
    <1>2. VRF prevents Byzantine leader manipulation
        BY VRFLeaderSelectionDeterminism, VRF!VRFUnpredictabilityProperty
    <1>3. Reduced Byzantine stake insufficient for certificate creation
        BY <1>1, <1>2 DEF StakeOfSet, RequiredStake
    <1> QED BY <1>3

LEMMA EconomicSlashingEnforcement ==
    \A v \in ByzantineValidators :
        \A reason \in {"double_vote", "invalid_cert", "withhold_shreds"} :
            EconomicModel!SlashValidator(v, EconomicModel!SlashingAmount(v, reason), reason) =>
                EconomicModel!slashedStake'[v] > EconomicModel!slashedStake[v]
PROOF
    <1>1. SUFFICES ASSUME NEW v \in ByzantineValidators,
                          NEW reason \in {"double_vote", "invalid_cert", "withhold_shreds"},
                          EconomicModel!SlashValidator(v, EconomicModel!SlashingAmount(v, reason), reason)
                   PROVE EconomicModel!slashedStake'[v] > EconomicModel!slashedStake[v]
        OBVIOUS
    <1>2. EconomicModel!SlashingAmount(v, reason) > 0
        BY DEF EconomicModel!SlashingAmount, EconomicModel!TotalStake
    <1>3. EconomicModel!slashedStake'[v] = EconomicModel!slashedStake[v] + EconomicModel!SlashingAmount(v, reason)
        BY DEF EconomicModel!SlashValidator
    <1> QED BY <1>2, <1>3

----------------------------------------------------------------------------
(* Chain Consistency *)

\* All honest validators have consistent finalized chains
ChainConsistency ==
    \A v1, v2 \in (Validators \ (ByzantineValidators \cup OfflineValidators)) :
        \A slot \in 1..currentSlot :
            /\ Len(votorFinalizedChain[v1]) >= slot
            /\ Len(votorFinalizedChain[v2]) >= slot
            => votorFinalizedChain[v1][slot] = votorFinalizedChain[v2][slot]

THEOREM ChainConsistencyTheorem ==
    Spec => []ChainConsistency
PROOF
    <1>1. []SafetyInvariant => []ChainConsistency
        <2>1. SUFFICES ASSUME SafetyInvariant,
                              NEW v1 \in (Validators \ (ByzantineValidators \cup OfflineValidators)),
                              NEW v2 \in (Validators \ (ByzantineValidators \cup OfflineValidators)),
                              NEW slot \in 1..currentSlot,
                              Len(votorFinalizedChain[v1]) >= slot,
                              Len(votorFinalizedChain[v2]) >= slot
                       PROVE votorFinalizedChain[v1][slot] = votorFinalizedChain[v2][slot]
            BY DEF ChainConsistency

        <2>2. votorFinalizedChain[v1][slot] \in finalizedBlocks[slot]
            BY HonestFinalizationLemma, <2>1

        <2>3. votorFinalizedChain[v2][slot] \in finalizedBlocks[slot]
            BY HonestFinalizationLemma, <2>1

        <2>4. votorFinalizedChain[v1][slot] = votorFinalizedChain[v2][slot]
            BY <2>2, <2>3, SafetyInvariant DEF SafetyInvariant

        <2> QED BY <2>4

    <1> QED BY <1>1, SafetyTheorem

----------------------------------------------------------------------------
(* Byzantine Fault Tolerance *)

\* Safety maintained with up to 20% Byzantine stake, enhanced by economic slashing
ByzantineSafetyResilience ==
    LET effectiveByzantineStake == StakeOfSet(ByzantineValidators) -
                                 Utils!Sum([v \in ByzantineValidators |-> EconomicModel!slashedStake[v]])
    IN effectiveByzantineStake <= TotalStakeSum \div 5 => []SafetyInvariant

THEOREM ByzantineResilienceTheorem ==
    /\ EconomicModel!SlashingCorrectness
    /\ VRFLeaderSelectionDeterminism
    /\ RotorNonEquivocationTheorem
    => LET effectiveByzantineStake == StakeOfSet(ByzantineValidators) -
                                    Utils!Sum([v \in ByzantineValidators |-> EconomicModel!slashedStake[v]])
       IN effectiveByzantineStake <= TotalStakeSum \div 5 => (Spec => []SafetyInvariant)
PROOF
    <1>1. ASSUME LET effectiveByzantineStake == StakeOfSet(ByzantineValidators) -
                                              Utils!Sum([v \in ByzantineValidators |-> EconomicModel!slashedStake[v]])
                 IN effectiveByzantineStake <= TotalStakeSum \div 5
          PROVE (4 * TotalStakeSum) \div 5 > TotalStakeSum - effectiveByzantineStake
        BY <1>1

    <1>2. ASSUME LET effectiveByzantineStake == StakeOfSet(ByzantineValidators) -
                                              Utils!Sum([v \in ByzantineValidators |-> EconomicModel!slashedStake[v]])
                 IN effectiveByzantineStake <= TotalStakeSum \div 5
          PROVE (3 * TotalStakeSum) \div 5 > effectiveByzantineStake
        BY <1>2

    <1>3. Economic slashing reduces Byzantine power over time
        BY EconomicSlashingEnforcement, EconomicModel!SlashingCorrectness

    <1>4. VRF prevents Byzantine leader manipulation
        BY VRFLeaderSelectionDeterminism, VRF!VRFUnpredictabilityProperty

    <1>5. Rotor non-equivocation prevents data withholding attacks
        BY RotorNonEquivocationTheorem

    <1>6. ASSUME LET effectiveByzantineStake == StakeOfSet(ByzantineValidators) -
                                              Utils!Sum([v \in ByzantineValidators |-> EconomicModel!slashedStake[v]])
                 IN effectiveByzantineStake <= TotalStakeSum \div 5
          PROVE ByzantineCannotForceCertificate
        BY <1>2, <1>3, <1>4, <1>5, ByzantineCannotForceCertificate

    <1> QED BY <1>1, <1>2, <1>6, SafetyTheorem

----------------------------------------------------------------------------
(* Boundary Conditions *)

\* Safety at exactly 20% Byzantine threshold
THEOREM ExactThresholdSafety ==
    StakeOfSet(ByzantineValidators) = TotalStakeSum \div 5 => (Spec => []SafetyInvariant)
PROOF
    <1>1. StakeOfSet(ByzantineValidators) = TotalStakeSum \div 5 =>
          StakeOfSet(Validators \ ByzantineValidators) = (4 * TotalStakeSum) \div 5
        BY DEF StakeOfSet, TotalStakeSum

    <1>2. (3 * TotalStakeSum) \div 5 = (3 * ((TotalStakeSum \div 5) * 5)) \div 5
        BY SimpleArithmetic

    <1>3. RequiredStake["fast"] = (4 * TotalStakeSum) \div 5
        BY DEF FastCertificate, RequiredStake

    <1>4. RequiredStake["slow"] = (3 * TotalStakeSum) \div 5
        BY DEF SlowCertificate, RequiredStake

    <1>5. StakeOfSet(ByzantineValidators) <= TotalStakeSum \div 5
        BY <1>1

    <1>6. StakeOfSet(Validators \ ByzantineValidators) >= (3 * TotalStakeSum) \div 5
        BY <1>1, <1>5 DEF StakeOfSet

    <1>7. HonestSingleVoteTheorem
        BY HonestSingleVoteTheorem

    <1> QED BY <1>6, <1>7, SafetyTheorem

\* Safety violation at >20% Byzantine threshold
THEOREM ThresholdViolation ==
    StakeOfSet(ByzantineValidators) > TotalStakeSum \div 5 =>
        \E execution : ~SafetyInvariant
PROOF
    <1>1. ASSUME StakeOfSet(ByzantineValidators) > TotalStakeSum \div 5
          PROVE StakeOfSet(ByzantineValidators) * 3 > (3 * TotalStakeSum) \div 5
        BY <1>1

    <1>2. StakeOfSet(ByzantineValidators) > TotalStakeSum \div 5 =>
          StakeOfSet(ByzantineValidators) * 3 > (3 * TotalStakeSum) \div 5
        BY <1>1

    <1>3. \* Construct actual safety violation
          LET byzantineStake == StakeOfSet(ByzantineValidators)
              slowThreshold == (3 * TotalStakeSum) \div 5
              targetSlot == 1
              block1 == [slot |-> targetSlot, hash |-> "hash1", data |-> "data1"]
              block2 == [slot |-> targetSlot, hash |-> "hash2", data |-> "data2"]
              \* Byzantine validators can create two conflicting certificates
              byzantineValidators1 == CHOOSE S \subseteq ByzantineValidators :
                                        StakeOfSet(S) >= slowThreshold
              byzantineValidators2 == CHOOSE S \subseteq ByzantineValidators :
                                        StakeOfSet(S) >= slowThreshold /\ S \cap byzantineValidators1 # {}
              cert1 == [type |-> "slow", slot |-> targetSlot, block |-> block1.hash,
                       stake |-> StakeOfSet(byzantineValidators1),
                       signatures |-> [sigs |-> {[validator |-> v, signature |-> "sig1"] : v \in byzantineValidators1}]]
              cert2 == [type |-> "slow", slot |-> targetSlot, block |-> block2.hash,
                       stake |-> StakeOfSet(byzantineValidators2),
                       signatures |-> [sigs |-> {[validator |-> v, signature |-> "sig2"] : v \in byzantineValidators2}]]
          IN /\ byzantineStake > TotalStakeSum \div 5
             /\ StakeOfSet(byzantineValidators1) >= slowThreshold
             /\ StakeOfSet(byzantineValidators2) >= slowThreshold
             /\ block1 # block2
             /\ cert1 \in Certificates
             /\ cert2 \in Certificates
             /\ block1 \in finalizedBlocks[targetSlot]
             /\ block2 \in finalizedBlocks[targetSlot]
        BY <1>1, <1>2, ByzantineAttackConstruction

    <1>4. \E slot : \E b1, b2 \in finalizedBlocks'[slot] : b1 # b2
        BY <1>3

    <1> QED BY <1>4 DEF SafetyInvariant

\* Byzantine attack construction helper
LEMMA ByzantineAttackConstruction ==
    StakeOfSet(ByzantineValidators) > TotalStakeSum \div 5 =>
    \E slot \in 1..MaxSlot, b1, b2 \in Types!Block :
        /\ b1 # b2
        /\ \E cert1, cert2 \in Certificates :
            /\ cert1.slot = slot /\ cert1.block = b1.hash
            /\ cert2.slot = slot /\ cert2.block = b2.hash
            /\ cert1.type = "slow" /\ cert2.type = "slow"
            /\ cert1.stake >= (3 * TotalStakeSum) \div 5
            /\ cert2.stake >= (3 * TotalStakeSum) \div 5
PROOF
    <1>1. StakeOfSet(ByzantineValidators) > TotalStakeSum \div 5
        BY DEF ByzantineAttackConstruction

    <1>2. Byzantine validators can split their stake across conflicting certificates
        BY <1>1, StakeArithmetic

    <1>3. Each certificate can achieve slow path threshold independently
        BY <1>1, <1>2 DEF RequiredStake

    <1> QED BY <1>2, <1>3

\* Stake arithmetic helper
LEMMA StakeArithmetic ==
    \A S \subseteq Validators : StakeOfSet(S) > TotalStakeSum \div 5 =>
        \E S1, S2 \subseteq S :
            /\ StakeOfSet(S1) >= (3 * TotalStakeSum) \div 5
            /\ StakeOfSet(S2) >= (3 * TotalStakeSum) \div 5
            /\ S1 \cap S2 # {}
PROOF
    BY SimpleArithmetic, PigeonholePrinciple

----------------------------------------------------------------------------
(* No Conflicting Finalization Theorem *)

\* Main safety property - no conflicting blocks finalized in same slot
NoConflictingFinalization ==
    \A slot \in 1..MaxSlot :
        \A b1, b2 \in finalizedBlocks[slot] :
            b1.hash = b2.hash

THEOREM NoConflictingFinalizationTheorem ==
    /\ RotorNonEquivocationTheorem
    /\ VRFLeaderSelectionDeterminism
    /\ EconomicModel!SlashingCorrectness
    => (Spec => []NoConflictingFinalization)
PROOF
    <1>1. []SafetyInvariant => []NoConflictingFinalization
        <2>1. SUFFICES ASSUME SafetyInvariant,
                              NEW slot \in 1..MaxSlot,
                              NEW b1 \in finalizedBlocks[slot],
                              NEW b2 \in finalizedBlocks[slot]
                       PROVE b1.hash = b2.hash
            BY DEF NoConflictingFinalization

        <2>2. b1 = b2
            BY <2>1, SafetyInvariant DEF SafetyInvariant

        <2>3. b1.hash = b2.hash
            BY <2>2

        <2> QED BY <2>3

    <1> QED BY <1>1, SafetyTheorem

----------------------------------------------------------------------------
(* Byzantine Tolerance Theorem *)

\* Safety maintained with ≤20% Byzantine stake
ByzantineTolerance ==
    LET effectiveByzantineStake == StakeOfSet(ByzantineValidators) -
                                 Utils!Sum([v \in ByzantineValidators |-> EconomicModel!slashedStake[v]])
    IN effectiveByzantineStake <= TotalStakeSum \div 5 => []SafetyInvariant

THEOREM ByzantineToleranceTheorem ==
    /\ EconomicModel!SlashingCorrectness
    /\ VRFLeaderSelectionDeterminism
    /\ RotorNonEquivocationTheorem
    => ByzantineTolerance
PROOF
    <1>1. ASSUME LET effectiveByzantineStake == StakeOfSet(ByzantineValidators) -
                                              Utils!Sum([v \in ByzantineValidators |-> EconomicModel!slashedStake[v]])
                 IN effectiveByzantineStake <= TotalStakeSum \div 5
          PROVE []SafetyInvariant
        BY ByzantineResilienceTheorem

    <1> QED BY <1>1 DEF ByzantineTolerance

----------------------------------------------------------------------------
(* Fast Path Safety *)

\* Fast finalization prevents conflicting slow finalization
FastPathSafety ==
    \A slot \in 1..MaxSlot :
        \A b \in finalizedBlocks[slot] :
            (\E cert \in Certificates : cert.slot = slot /\ cert.block = b.hash /\ cert.type = "fast") =>
                ~(\E cert2 \in Certificates : cert2.slot = slot /\ cert2.type = "slow" /\ cert2.block # b.hash)

THEOREM FastPathSafetyTheorem ==
    Spec => []FastPathSafety
PROOF
    <1>1. SUFFICES ASSUME NEW slot \in 1..MaxSlot,
                          NEW b \in finalizedBlocks[slot],
                          \E cert \in Certificates : cert.slot = slot /\ cert.block = b.hash /\ cert.type = "fast"
                   PROVE ~(\E cert2 \in Certificates : cert2.slot = slot /\ cert2.type = "slow" /\ cert2.block # b.hash)
        BY DEF FastPathSafety

    <1>2. LET fastCert == CHOOSE cert \in Certificates : cert.slot = slot /\ cert.block = b.hash /\ cert.type = "fast"
          IN fastCert.stake >= (4 * TotalStakeSum) \div 5
        BY <1>1 DEF FastCertificate, RequiredStake

    <1>3. \A cert2 \in Certificates :
            cert2.slot = slot /\ cert2.type = "slow" =>
                cert2.block = b.hash
        <2>1. ASSUME NEW cert2 \in Certificates,
                     cert2.slot = slot,
                     cert2.type = "slow"
              PROVE cert2.block = b.hash
            <3>1. cert2.stake >= (3 * TotalStakeSum) \div 5
                BY <2>1 DEF SlowCertificate, RequiredStake
            <3>2. LET V1 == {v \in Validators : \E sig \in fastCert.signatures.sigs : sig.validator = v}
                      V2 == {v \in Validators : \E sig \in cert2.signatures.sigs : sig.validator = v}
                  IN StakeOfSet(V1) + StakeOfSet(V2) > TotalStakeSum
                BY <1>2, <3>1
            <3>3. V1 \cap V2 # {}
                BY <3>2, PigeonholePrinciple
            <3>4. \E v \in V1 \cap V2 : v \notin ByzantineValidators
                BY <3>3, HonestMajorityAssumption
            <3>5. cert2.block = b.hash
                BY <3>4, HonestSingleVote
            <3> QED BY <3>5
        <2> QED BY <2>1

    <1> QED BY <1>3

----------------------------------------------------------------------------
(* Slow Path Safety *)

\* Two-round finalization maintains consistency
SlowPathSafety ==
    \A slot \in 1..MaxSlot :
        \A b1, b2 \in finalizedBlocks[slot] :
            /\ (\E cert1 \in Certificates : cert1.slot = slot /\ cert1.block = b1.hash /\ cert1.type = "slow")
            /\ (\E cert2 \in Certificates : cert2.slot = slot /\ cert2.block = b2.hash /\ cert2.type = "slow")
            => b1.hash = b2.hash

THEOREM SlowPathSafetyTheorem ==
    Spec => []SlowPathSafety
PROOF
    <1>1. SUFFICES ASSUME NEW slot \in 1..MaxSlot,
                          NEW b1 \in finalizedBlocks[slot],
                          NEW b2 \in finalizedBlocks[slot],
                          \E cert1 \in Certificates : cert1.slot = slot /\ cert1.block = b1.hash /\ cert1.type = "slow",
                          \E cert2 \in Certificates : cert2.slot = slot /\ cert2.block = b2.hash /\ cert2.type = "slow"
                   PROVE b1.hash = b2.hash
        BY DEF SlowPathSafety

    <1>2. LET cert1 == CHOOSE cert \in Certificates : cert.slot = slot /\ cert.block = b1.hash /\ cert.type = "slow"
              cert2 == CHOOSE cert \in Certificates : cert.slot = slot /\ cert.block = b2.hash /\ cert.type = "slow"
          IN /\ cert1.stake >= (3 * TotalStakeSum) \div 5
             /\ cert2.stake >= (3 * TotalStakeSum) \div 5
        BY <1>1 DEF SlowCertificate, RequiredStake

    <1>3. LET V1 == {v \in Validators : \E sig \in cert1.signatures.sigs : sig.validator = v}
              V2 == {v \in Validators : \E sig \in cert2.signatures.sigs : sig.validator = v}
          IN StakeOfSet(V1) + StakeOfSet(V2) > TotalStakeSum
        BY <1>2

    <1>4. V1 \cap V2 # {}
        BY <1>3, PigeonholePrinciple

    <1>5. \E v \in V1 \cap V2 : v \notin ByzantineValidators
        BY <1>4, HonestMajorityAssumption

    <1>6. b1.hash = b2.hash
        BY <1>5, HonestSingleVote

    <1> QED BY <1>6

----------------------------------------------------------------------------
(* Vote Uniqueness *)

\* Honest validators vote at most once per slot
VoteUniqueness ==
    \A v \in (Validators \ (ByzantineValidators \cup OfflineValidators)) :
        \A slot \in 1..MaxSlot :
            \A vote1, vote2 \in votorVotes[v] :
                /\ vote1.slot = slot
                /\ vote2.slot = slot
                /\ vote1.type \in {"notarization", "finalization", "skip"}
                /\ vote2.type \in {"notarization", "finalization", "skip"}
                => vote1 = vote2

THEOREM VoteUniquenessTheorem ==
    Spec => []VoteUniqueness
PROOF
    <1>1. Init => VoteUniqueness
        BY DEF Init, VoteUniqueness

    <1>2. VoteUniqueness /\ Next => VoteUniqueness'
        <2>1. ASSUME VoteUniqueness,
                     VotorAction
              PROVE VoteUniqueness'
            <3>1. SUFFICES ASSUME NEW v \in (Validators \ (ByzantineValidators \cup OfflineValidators)),
                                  NEW slot \in 1..MaxSlot,
                                  NEW vote1 \in votorVotes'[v],
                                  NEW vote2 \in votorVotes'[v],
                                  vote1.slot = slot,
                                  vote2.slot = slot,
                                  vote1.type \in {"notarization", "finalization", "skip"},
                                  vote2.type \in {"notarization", "finalization", "skip"}
                           PROVE vote1 = vote2
                BY DEF VoteUniqueness

            <3>2. CASE vote1 \in votorVotes[v] /\ vote2 \in votorVotes[v]
                BY <3>2, VoteUniqueness

            <3>3. CASE vote1 \notin votorVotes[v] \/ vote2 \notin votorVotes[v]
                <4>1. Honest validators follow protocol rules
                    BY DEF Votor!CastNotarVote, Votor!CastFinalizationVote, Votor!CastSkipVote
                <4>2. Protocol prevents multiple votes per slot
                    BY <4>1, Votor!VotingProtocolInvariant
                <4>3. vote1 = vote2
                    BY <4>2, <3>3
                <4> QED BY <4>3

            <3> QED BY <3>2, <3>3

        <2> QED BY <2>1 DEF Next

    <1> QED BY <1>1, <1>2, PTL DEF Spec

----------------------------------------------------------------------------
(* Stake Arithmetic Lemmas *)

\* Helper lemma about stake threshold overlaps
LEMMA StakeThresholdOverlap ==
    \A S1, S2 \in SUBSET Validators :
        /\ StakeOfSet(S1) >= (3 * TotalStakeSum) \div 5
        /\ StakeOfSet(S2) >= (3 * TotalStakeSum) \div 5
        => S1 \cap S2 # {}
PROOF
    <1>1. SUFFICES ASSUME NEW S1 \in SUBSET Validators,
                          NEW S2 \in SUBSET Validators,
                          StakeOfSet(S1) >= (3 * TotalStakeSum) \div 5,
                          StakeOfSet(S2) >= (3 * TotalStakeSum) \div 5
                   PROVE S1 \cap S2 # {}
        BY DEF StakeThresholdOverlap

    <1>2. StakeOfSet(S1) + StakeOfSet(S2) >= (6 * TotalStakeSum) \div 5
        BY <1>1

    <1>3. (6 * TotalStakeSum) \div 5 > TotalStakeSum
        BY SimpleArithmetic

    <1>4. StakeOfSet(S1) + StakeOfSet(S2) > TotalStakeSum
        BY <1>2, <1>3

    <1> QED BY <1>4, PigeonholePrinciple

\* Lemma about fast path threshold implications
LEMMA FastPathThresholdImplication ==
    \A S \in SUBSET Validators :
        StakeOfSet(S) >= (4 * TotalStakeSum) \div 5 =>
            StakeOfSet(S) >= (3 * TotalStakeSum) \div 5
PROOF
    <1>1. SUFFICES ASSUME NEW S \in SUBSET Validators,
                          StakeOfSet(S) >= (4 * TotalStakeSum) \div 5
                   PROVE StakeOfSet(S) >= (3 * TotalStakeSum) \div 5
        BY DEF FastPathThresholdImplication

    <1>2. (4 * TotalStakeSum) \div 5 >= (3 * TotalStakeSum) \div 5
        BY SimpleArithmetic

    <1> QED BY <1>1, <1>2

\* Lemma about Byzantine stake bounds
LEMMA ByzantineStakeBound ==
    StakeOfSet(ByzantineValidators) <= TotalStakeSum \div 5 =>
        StakeOfSet(Validators \ ByzantineValidators) >= (4 * TotalStakeSum) \div 5
PROOF
    <1>1. SUFFICES ASSUME StakeOfSet(ByzantineValidators) <= TotalStakeSum \div 5
                   PROVE StakeOfSet(Validators \ ByzantineValidators) >= (4 * TotalStakeSum) \div 5
        BY DEF ByzantineStakeBound

    <1>2. StakeOfSet(Validators \ ByzantineValidators) = TotalStakeSum - StakeOfSet(ByzantineValidators)
        BY DEF StakeOfSet, TotalStakeSum

    <1>3. TotalStakeSum - TotalStakeSum \div 5 = (4 * TotalStakeSum) \div 5
        BY SimpleArithmetic

    <1>4. StakeOfSet(Validators \ ByzantineValidators) >= (4 * TotalStakeSum) \div 5
        BY <1>1, <1>2, <1>3

    <1> QED BY <1>4

----------------------------------------------------------------------------
(* Cryptographic Assumptions *)

\* BLS signature integrity and non-forgeability
CryptographicIntegrityAssumption ==
    /\ \A v \in (Validators \ ByzantineValidators) :
        \A msg1, msg2 \in Nat :
            Types!SignMessage(v, msg1) = Types!SignMessage(v, msg2) => msg1 = msg2
    /\ \A v1, v2 \in (Validators \ ByzantineValidators) :
        \A msg \in Nat :
            v1 # v2 => Types!SignMessage(v1, msg) # Types!SignMessage(v2, msg)
    /\ \A sig \in Types!BLSSignature :
        sig.valid => \E v \in Validators, msg \in Nat : sig = Types!SignMessage(v, msg)

\* Hash function collision resistance
HashCollisionResistance ==
    \A data1, data2 \in Seq(Nat) :
        Types!ComputeBlockHash(data1) = Types!ComputeBlockHash(data2) => data1 = data2

\* Combined cryptographic integrity
CryptographicIntegrity ==
    /\ CryptographicIntegrityAssumption
    /\ HashCollisionResistance
    /\ \A v \in (Validators \ ByzantineValidators) :
        \A shred1, shred2 \in UNION {Rotor!blockShreds[b][v] : b \in DOMAIN Rotor!blockShreds} :
            /\ shred1.slot = shred2.slot
            /\ shred1.index = shred2.index
            => shred1 = shred2

THEOREM CryptographicIntegrityTheorem ==
    CryptographicAssumptions => CryptographicIntegrity
PROOF
    <1>1. CryptographicAssumptions => CryptographicIntegrityAssumption
        BY DEF CryptographicAssumptions, CryptographicIntegrityAssumption

    <1>2. CryptographicAssumptions => HashCollisionResistance
        BY DEF CryptographicAssumptions, HashCollisionResistance

    <1>3. CryptographicIntegrityAssumption /\ HashCollisionResistance =>
          (\A v \in (Validators \ ByzantineValidators) :
            \A shred1, shred2 \in UNION {Rotor!blockShreds[b][v] : b \in DOMAIN Rotor!blockShreds} :
                /\ shred1.slot = shred2.slot
                /\ shred1.index = shred2.index
                => shred1 = shred2)
        <2>1. SUFFICES ASSUME CryptographicIntegrityAssumption,
                              HashCollisionResistance,
                              NEW v \in (Validators \ ByzantineValidators),
                              NEW shred1 \in UNION {Rotor!blockShreds[b][v] : b \in DOMAIN Rotor!blockShreds},
                              NEW shred2 \in UNION {Rotor!blockShreds[b][v] : b \in DOMAIN Rotor!blockShreds},
                              shred1.slot = shred2.slot,
                              shred1.index = shred2.index
                       PROVE shred1 = shred2
            OBVIOUS

        <2>2. shred1.signature = shred2.signature
            BY <2>1, CryptographicIntegrityAssumption DEF Types!Shred

        <2>3. shred1.data = shred2.data
            BY <2>1, <2>2, HashCollisionResistance DEF Types!Shred

        <2>4. shred1 = shred2
            BY <2>1, <2>2, <2>3 DEF Types!Shred

        <2> QED BY <2>4

    <1> QED BY <1>1, <1>2, <1>3 DEF CryptographicIntegrity

----------------------------------------------------------------------------
(* Helper Lemmas *)

LEMMA HonestFinalizationLemma ==
    \A v \in (Validators \\ (ByzantineValidators \cup OfflineValidators)) :
        \A slot \in 1..Len(votorFinalizedChain[v]) :
            votorFinalizedChain[v][slot] \in finalizedBlocks[slot]
PROOF
    <1>1. SUFFICES ASSUME NEW v \in (Validators \\ (ByzantineValidators \cup OfflineValidators)),
                          NEW slot \in 1..Len(votorFinalizedChain[v])
                   PROVE votorFinalizedChain[v][slot] \in finalizedBlocks[slot]
        BY DEF HonestFinalizationLemma

    <1>2. votorFinalizedChain[v] \in Seq(Types!Block)
        BY DEF votorFinalizedChain

    <1>3. \E cert \in Certificates :
          /\ cert.slot = slot
          /\ cert.block = votorFinalizedChain[v][slot].hash
          /\ (FastCertificate(cert) \/ SlowCertificate(cert))
        BY <1>2 DEF Votor!FinalizeBlock

    <1>4. votorFinalizedChain[v][slot] \in finalizedBlocks[slot]
        BY <1>3 DEF finalizedBlocks

    <1> QED BY <1>4

LEMMA RequiredStakeForType ==
    /\ (4 * TotalStakeSum) \div 5 \in Nat  \* Fast path
    /\ (3 * TotalStakeSum) \div 5 \in Nat  \* Slow path
    /\ (3 * TotalStakeSum) \div 5 \in Nat  \* Skip
PROOF
    <1>1. TotalStakeSum \in Nat
        BY DEF TotalStakeSum, StakeOfSet, Stake

    <1>2. \A n \in Nat : (4 * n) \div 5 \in Nat
        BY SimpleArithmetic

    <1>3. \A n \in Nat : (3 * n) \div 5 \in Nat
        BY SimpleArithmetic

    <1> QED BY <1>1, <1>2, <1>3

LEMMA PigeonholePrinciple ==
    \A S1, S2 \in SUBSET Validators :
        StakeOfSet(S1) + StakeOfSet(S2) > TotalStakeSum =>
            S1 \cap S2 # {}
PROOF
    <1>1. SUFFICES ASSUME NEW S1 \in SUBSET Validators,
                          NEW S2 \in SUBSET Validators,
                          StakeOfSet(S1) + StakeOfSet(S2) > TotalStakeSum
                   PROVE S1 \cap S2 # {}
        BY DEF PigeonholePrinciple
    <1>2. ASSUME S1 \cap S2 = {}
          PROVE StakeOfSet(S1 \cup S2) = StakeOfSet(S1) + StakeOfSet(S2)
        BY <1>2 DEF StakeOfSet
    <1>3. S1 \cup S2 \subseteq Validators
        BY <1>1
    <1>4. StakeOfSet(S1 \cup S2) <= TotalStakeSum
        BY <1>3 DEF TotalStakeSum, StakeOfSet
    <1>5. StakeOfSet(S1) + StakeOfSet(S2) <= TotalStakeSum
        BY <1>2, <1>4
    <1>6. FALSE
        BY <1>1, <1>5
    <1> QED BY <1>6

LEMMA CryptographicIntegrity ==
    \A v \in (Validators \ ByzantineValidators) :
        \A shred1, shred2 \in UNION {Rotor!blockShreds[b][v] : b \in DOMAIN Rotor!blockShreds} :
            /\ shred1.slot = shred2.slot
            /\ shred1.index = shred2.index
            => shred1 = shred2
PROOF
    <1>1. Honest validators use cryptographic signatures
        BY DEF Types!Shred, Crypto!Sign
    <1>2. Cryptographic signatures prevent forgery
        BY CryptographicAssumptions
    <1>3. Same slot and index with honest validator implies same shred
        BY <1>1, <1>2
    <1> QED BY <1>3

LEMMA VRFLeaderWindowSafety ==
    \A slot \in 1..MaxSlot, view1, view2 \in 1..MaxView, validators \in SUBSET Validators, stakeMap \in [Validators -> Nat] :
        LET windowIndex == slot \div LeaderWindowSize
            baseLeader == VRF!VRFComputeWindowLeader(windowIndex, validators, stakeMap)
            leader1 == VRF!VRFIsLeaderForView(baseLeader, slot, view1, validators, stakeMap, LeaderWindowSize)
            leader2 == VRF!VRFIsLeaderForView(baseLeader, slot, view2, validators, stakeMap, LeaderWindowSize)
        IN view1 = view2 => leader1 = leader2
PROOF
    <1>1. VRF!VRFIsLeaderForView is deterministic for same view
        BY DEF VRF!VRFIsLeaderForView, VRF!VRFComputeWindowLeader, VRF!VRFRotateLeaderInWindow
    <1>2. Same view implies same leader rotation
        BY <1>1, VRFLeaderSelectionDeterminism
    <1> QED BY <1>2

\* Additional helper lemma for honest majority
LEMMA HonestMajorityInCertificates ==
    \A cert \in Certificates :
        cert.stake >= (3 * TotalStakeSum) \div 5 =>
            LET honestValidators == {v \in cert.validators : v \notin ByzantineValidators}
            IN StakeOfSet(honestValidators) > (2 * TotalStakeSum) \div 5
PROOF
    <1>1. SUFFICES ASSUME NEW cert \in Certificates,
                          cert.stake >= (3 * TotalStakeSum) \div 5
                   PROVE LET honestValidators == {v \in cert.validators : v \notin ByzantineValidators}
                         IN StakeOfSet(honestValidators) > (2 * TotalStakeSum) \div 5
        BY DEF HonestMajorityInCertificates

    <1>2. LET byzantineInCert == {v \in cert.validators : v \in ByzantineValidators}
              honestInCert == {v \in cert.validators : v \notin ByzantineValidators}
          IN /\ cert.validators = byzantineInCert \cup honestInCert
             /\ byzantineInCert \cap honestInCert = {}
        BY DEF cert.validators

    <1>3. cert.stake = StakeOfSet(cert.validators)
        BY DEF cert.stake, StakeOfSet

    <1>4. StakeOfSet(cert.validators) = StakeOfSet(byzantineInCert) + StakeOfSet(honestInCert)
        BY <1>2 DEF StakeOfSet

    <1>5. StakeOfSet(byzantineInCert) <= StakeOfSet(ByzantineValidators) <= TotalStakeSum \div 5
        BY ByzantineAssumption DEF StakeOfSet

    <1>6. StakeOfSet(honestInCert) = cert.stake - StakeOfSet(byzantineInCert)
        BY <1>3, <1>4

    <1>7. StakeOfSet(honestInCert) >= (3 * TotalStakeSum) \div 5 - TotalStakeSum \div 5
        BY <1>1, <1>5, <1>6

    <1>8. (3 * TotalStakeSum) \div 5 - TotalStakeSum \div 5 = (2 * TotalStakeSum) \div 5
        BY SimpleArithmetic

    <1>9. StakeOfSet(honestInCert) >= (2 * TotalStakeSum) \div 5
        BY <1>7, <1>8

    <1>10. StakeOfSet(honestInCert) > (2 * TotalStakeSum) \div 5
        BY <1>9, <1>1, StrictInequalityFromCertificateThreshold

    <1> QED BY <1>10

\* Helper lemma for strict inequality
LEMMA StrictInequalityFromCertificateThreshold ==
    \A cert \in Certificates :
        cert.stake >= (3 * TotalStakeSum) \div 5 =>
            cert.stake > (3 * TotalStakeSum) \div 5 - 1
PROOF
    BY DEF Certificates, Types!Certificate

LEMMA HonestMajorityAssumption ==
    StakeOfSet(Validators \ ByzantineValidators) > StakeOfSet(ByzantineValidators)
PROOF
    <1>1. StakeOfSet(ByzantineValidators) <= TotalStakeSum \div 5
        BY ByzantineAssumption

    <1>2. StakeOfSet(Validators \ ByzantineValidators) =
          TotalStakeSum - StakeOfSet(ByzantineValidators)
        BY DEF StakeOfSet, TotalStakeSum

    <1>3. TotalStakeSum - TotalStakeSum \div 5 = (4 * TotalStakeSum) \div 5
        BY SimpleArithmetic

    <1>4. StakeOfSet(Validators \ ByzantineValidators) >= (4 * TotalStakeSum) \div 5
        BY <1>1, <1>2, <1>3

    <1>5. (4 * TotalStakeSum) \div 5 > TotalStakeSum \div 5
        BY TotalStakeSum > 0

    <1> QED BY <1>1, <1>4, <1>5

============================================================================
