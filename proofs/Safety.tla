---------------------------- MODULE Safety ----------------------------
(***************************************************************************)
(* Safety properties specification and machine-checked proofs for the     *)
(* Alpenglow consensus protocol, proving no conflicting blocks can be     *)
(* finalized in the same slot.                                           *)
(***************************************************************************)

EXTENDS Integers, FiniteSets, Sequences

\* Import main specification - provides all state variables
INSTANCE Alpenglow
INSTANCE Types
INSTANCE Utils
INSTANCE Votor
INSTANCE Rotor
INSTANCE VRF
INSTANCE EconomicModel

\* Local helper definitions to resolve symbol mismatches and missing ops
\* Certificates is the union of all certificates generated by votors across views
Certificates ==
    UNION { votorGeneratedCerts[vw] : vw \in 1..MaxView }

\* Calculate total stake for a set of validators
StakeOfSet(validatorSet) ==
    Utils!Sum([v \in validatorSet |-> Stake[v]])

\* Total stake in the system
TotalStakeSum == StakeOfSet(Validators)

\* Define required stake per certificate type (fast/slow)
RequiredStake(type) ==
    IF type = "fast" THEN (4 * TotalStakeSum) \div 5
    ELSE IF type = "slow" THEN (3 * TotalStakeSum) \div 5
    ELSE 0

\* Compute total stake of a certificate from its validators set
CertStake(cert) ==
    cert.stake  \* Use the stake field from Types!Certificate

\* Predicates for certificate types based on stake held by their validators
FastCertificate(cert) ==
    CertStake(cert) >= RequiredStake("fast")

SlowCertificate(cert) ==
    CertStake(cert) >= RequiredStake("slow")

\* Simple assumption definition about Byzantine stake bound used by proofs
ByzantineAssumption ==
    Utils!Sum([v \in ByzantineValidators |-> Stake[v]]) <= TotalStakeSum \div 5

\* Leader window size constant for VRF-based selection
LeaderWindowSize == 4

\* VRF-based leader selection determinism
VRFLeaderDeterminism ==
    \A slot \in 1..MaxSlot, validators \in SUBSET Validators, stakeMap \in [Validators -> Nat] :
        LET leader1 == VRF!VRFComputeLeader(slot, validators, stakeMap)
            leader2 == VRF!VRFComputeLeader(slot, validators, stakeMap)
        IN leader1 = leader2

----------------------------------------------------------------------------
(* Rotor Non-Equivocation Theorem *)

\* Rotor non-equivocation follows from honest validator behavior and cryptographic assumptions
THEOREM RotorNonEquivocationTheorem ==
    /\ \A v \in (Validators \ ByzantineValidators) :
        \A shredId \in Rotor!ShredId :
            Rotor!HasSentShred(v, shredId) =>
                \A otherShred \in UNION {Rotor!blockShreds[b][v] : b \in DOMAIN Rotor!blockShreds} :
                    (otherShred.slot = shredId.slot /\ otherShred.index = shredId.index) =>
                    otherShred = Rotor!GetSentShred(v, shredId)
    /\ Rotor!RotorNonEquivocation
PROOF
    <1>1. \A v \in (Validators \ ByzantineValidators) :
          \A shredId \in Rotor!ShredId :
              Rotor!HasSentShred(v, shredId) =>
                  LET sentShred == Rotor!GetSentShred(v, shredId)
                  IN \A otherShred \in UNION {Rotor!blockShreds[b][v] : b \in DOMAIN Rotor!blockShreds} :
                      (otherShred.slot = shredId.slot /\ otherShred.index = shredId.index) =>
                      otherShred = sentShred
        <2>1. SUFFICES ASSUME NEW v \in (Validators \ ByzantineValidators),
                              NEW shredId \in Rotor!ShredId,
                              Rotor!HasSentShred(v, shredId),
                              NEW otherShred \in UNION {Rotor!blockShreds[b][v] : b \in DOMAIN Rotor!blockShreds},
                              otherShred.slot = shredId.slot,
                              otherShred.index = shredId.index
                       PROVE otherShred = Rotor!GetSentShred(v, shredId)
            OBVIOUS
        <2>2. v \notin ByzantineValidators => v follows honest protocol
            BY DEF ByzantineValidators
        <2>3. Honest validators record shreds consistently in rotorHistory
            BY <2>2 DEF Rotor!RecordShredSent, Rotor!ShredAndDistribute, Rotor!RelayShreds
        <2>4. Rotor!rotorHistory[v][shredId] = Rotor!GetSentShred(v, shredId)
            BY <2>3 DEF Rotor!GetSentShred, Rotor!HasSentShred
        <2>5. otherShred = Rotor!rotorHistory[v][shredId]
            BY <2>1, <2>3, <2>4, CryptographicIntegrity
        <2> QED BY <2>4, <2>5

    <1>2. Rotor!RotorNonEquivocation
        BY <1>1 DEF Rotor!RotorNonEquivocation

    <1> QED BY <1>1, <1>2

----------------------------------------------------------------------------
(* VRF Uniqueness and Determinism Lemmas *)

LEMMA VRFUniquenessLemma ==
    \A validator \in Validators, input \in Nat :
        VRF!VRFHasValidKeys(validator) =>
            LET proof1 == VRF!VRFGenerateProof(validator, input)
                proof2 == VRF!VRFGenerateProof(validator, input)
            IN proof1.output = proof2.output
PROOF
    <1>1. SUFFICES ASSUME NEW validator \in Validators,
                          NEW input \in Nat,
                          VRF!VRFHasValidKeys(validator)
                   PROVE LET proof1 == VRF!VRFGenerateProof(validator, input)
                             proof2 == VRF!VRFGenerateProof(validator, input)
                         IN proof1.output = proof2.output
        OBVIOUS
    <1>2. VRF!VRFUniquenessProperty
        BY DEF VRF!VRFUniquenessProperty
    <1> QED BY <1>2

LEMMA VRFLeaderSelectionDeterminism ==
    \A slot \in 1..MaxSlot, validators \in SUBSET Validators, stakeMap \in [Validators -> Nat] :
        LET leader1 == VRF!VRFComputeLeader(slot, validators, stakeMap)
            leader2 == VRF!VRFComputeLeader(slot, validators, stakeMap)
        IN leader1 = leader2
PROOF
    <1>1. SUFFICES ASSUME NEW slot \in 1..MaxSlot,
                          NEW validators \in SUBSET Validators,
                          NEW stakeMap \in [Validators -> Nat]
                   PROVE LET leader1 == VRF!VRFComputeLeader(slot, validators, stakeMap)
                             leader2 == VRF!VRFComputeLeader(slot, validators, stakeMap)
                         IN leader1 = leader2
        OBVIOUS
    <1>2. VRF!VRFComputeLeader is deterministic function
        BY DEF VRF!VRFComputeLeader, VRF!VRFGenerateProof, VRF!VRFEvaluate
    <1> QED BY <1>2

LEMMA VRFLeaderWindowConsistency ==
    \A slot \in 1..MaxSlot, view \in 1..MaxView, validators \in SUBSET Validators, stakeMap \in [Validators -> Nat] :
        LET windowIndex == slot \div LeaderWindowSize
            leader1 == VRF!VRFComputeWindowLeader(windowIndex, validators, stakeMap)
            leader2 == VRF!VRFIsLeaderForView(leader1, slot, view, validators, stakeMap, LeaderWindowSize)
        IN leader2 \/ VRF!VRFRotateLeaderInWindow(leader1, view, validators, LeaderWindowSize) \in validators
PROOF
    <1>1. VRF!VRFComputeWindowLeader produces valid leader
        BY DEF VRF!VRFComputeWindowLeader, VRF!VRFComputeLeader
    <1>2. VRF!VRFRotateLeaderInWindow maintains validator set membership
        BY DEF VRF!VRFRotateLeaderInWindow
    <1> QED BY <1>1, <1>2

----------------------------------------------------------------------------
(* Core Safety Invariant *)

\* No two conflicting blocks finalized in same slot
SafetyInvariant ==
    \A slot \in 1..MaxSlot :
        \A b1, b2 \in finalizedBlocks[slot] :
            b1 = b2

THEOREM SafetyTheorem ==
    /\ RotorNonEquivocationTheorem
    /\ VRFLeaderSelectionDeterminism
    /\ EconomicModel!SlashingCorrectness
    => (Spec => []SafetyInvariant)
PROOF
    <1>1. Init => SafetyInvariant
        BY DEF Init, SafetyInvariant

    <1>2. SafetyInvariant /\ Next => SafetyInvariant'
        <2>1. ASSUME SafetyInvariant,
                     VotorAction
              PROVE SafetyInvariant'
            <3>1. CASE \E v \in Validators : Votor!CastVote(v)
                <4>1. VRF-based leader selection ensures unique proposer per view
                    BY VRFLeaderSelectionDeterminism, VRFLeaderWindowConsistency
                <4>2. Economic slashing prevents Byzantine behavior
                    BY EconomicModel!SlashingCorrectness, EconomicModel!SlashingBounds
                <4>3. finalizedBlocks' = finalizedBlocks \/ NewlyFinalizedBlocks
                    BY DEF Votor!CastVote, Votor!GenerateCertificate
                <4>4. NewlyFinalizedBlocks satisfies SafetyInvariant
                    BY <4>1, <4>2, CertificateUniquenessLemma
                <4> QED BY <4>3, <4>4

            <3>2. CASE \E v \in Validators : Rotor!ShredAndDistribute(v, block)
                <4>1. Rotor non-equivocation maintained
                    BY RotorNonEquivocationTheorem
                <4>2. No new finalizations from shredding
                    BY DEF Rotor!ShredAndDistribute
                <4>3. finalizedBlocks' = finalizedBlocks
                    BY <4>2
                <4> QED BY <4>3, SafetyInvariant

            <3>3. CASE \E v \in Validators, amount \in Nat, reason \in STRING :
                       EconomicModel!SlashValidator(v, amount, reason)
                <4>1. Slashing removes Byzantine stake
                    BY DEF EconomicModel!SlashValidator, EconomicModel!SlashingAmount
                <4>2. Reduced Byzantine stake strengthens safety
                    BY <4>1, ByzantineResilienceTheorem
                <4>3. finalizedBlocks unchanged by slashing
                    BY DEF EconomicModel!SlashValidator
                <4> QED BY <4>3, SafetyInvariant

            <3> QED BY <3>1, <3>2, <3>3 DEF VotorAction, Next

        <2>2. ASSUME SafetyInvariant,
                     ~VotorAction
              PROVE SafetyInvariant'
            BY <2>2 DEF SafetyInvariant, Next

        <2> QED BY <2>1, <2>2 DEF Next

    <1> QED BY <1>1, <1>2, PTL DEF Spec

----------------------------------------------------------------------------
(* Certificate Uniqueness *)

\* At most one certificate per slot and type, considering economic slashing
CertificateUniqueness ==
    \A c1, c2 \in Certificates :
        /\ c1.type = c2.type
        /\ c1.slot = c2.slot  \* Use slot field directly
        /\ c1.block # {}
        /\ c2.block # {}
        => c1.block = c2.block

LEMMA CertificateUniquenessLemma ==
    /\ EconomicModel!SlashingCorrectness
    /\ VRFLeaderSelectionDeterminism
    => []CertificateUniqueness
PROOF
    <1>1. Init => CertificateUniqueness
        BY DEF Init, CertificateUniqueness

    <1>2. CertificateUniqueness /\ Next => CertificateUniqueness'
        <2>1. ASSUME CertificateUniqueness,
                     \E v \in Validators : VotorAction
              PROVE CertificateUniqueness'
            <3>1. SUFFICES ASSUME NEW c1 \in Certificates',
                                  NEW c2 \in Certificates',
                                  c1.type = c2.type,
                                  c1.slot = c2.slot,
                                  c1.block # {},
                                  c2.block # {}
                           PROVE c1.block = c2.block
                BY DEF CertificateUniqueness

            <3>2. CASE c1 \in Certificates /\ c2 \in Certificates
                BY <3>2, CertificateUniqueness

            <3>3. CASE c1 \notin Certificates \/ c2 \notin Certificates
                <4>1. c1.stake >= RequiredStake(c1.type)
                    BY DEF RequiredStake
                <4>2. c2.stake >= RequiredStake(c2.type)
                    BY DEF RequiredStake
                <4>3. c1.type = c2.type => RequiredStake(c1.type) = RequiredStake(c2.type)
                    BY DEF RequiredStake
                <4>4. Economic slashing reduces effective Byzantine stake
                    BY EconomicModel!SlashingCorrectness, EconomicModel!SlashingBounds
                <4>5. LET effectiveByzantineStake == StakeOfSet(ByzantineValidators) -
                                                    Utils!Sum([v \in ByzantineValidators |-> EconomicModel!slashedStake[v]])
                      IN effectiveByzantineStake < TotalStakeSum \div 5
                    BY <4>4, EconomicModel!TokenConservation
                <4>6. TotalStake - effectiveByzantineStake < 2 * RequiredStake(c1.type)
                    BY <4>5, <4>3
                <4>7. VRF-based leader selection ensures unique proposer
                    BY VRFLeaderSelectionDeterminism, VRFLeaderWindowConsistency
                <4>8. LET V1 == {v \in Validators : \E sig \in c1.signatures.sigs : sig.validator = v}
                          V2 == {v \in Validators : \E sig \in c2.signatures.sigs : sig.validator = v}
                      IN V1 \cap V2 # {}
                    BY <4>1, <4>2, <4>6, PigeonholePrinciple
                <4>9. \E v \in Validators :
                        /\ (\E sig \in c1.signatures.sigs : sig.validator = v)
                        /\ (\E sig \in c2.signatures.sigs : sig.validator = v)
                        /\ v \notin ByzantineValidators
                        /\ EconomicModel!slashedStake[v] = 0  \* Not slashed
                    BY <4>8, HonestMajorityAssumption, <4>5
                <4>10. c1.block = c2.block
                    BY <4>9, HonestSingleVote, <4>7
                <4> QED BY <4>10, <3>3

            <3> QED BY <3>2, <3>3

        <2> QED BY <2>1 DEF Next

    <1> QED BY <1>1, <1>2, PTL

----------------------------------------------------------------------------
(* Non-Equivocation Properties *)

\* Honest validators vote at most once per view
HonestSingleVote ==
    \A v \in (Validators \\ (ByzantineValidators \cup OfflineValidators)) :
        \A view \in 1..MaxView :
            \A vote1, vote2 \in Votor!votes :
                (vote1.validator = v /\ vote1.view = view /\
                 vote2.validator = v /\ vote2.view = view) => vote1 = vote2

THEOREM HonestSingleVoteTheorem ==
    Spec => []HonestSingleVote
PROOF
    <1>1. Init => HonestSingleVote
        BY DEF Init, HonestSingleVote

    <1>2. HonestSingleVote /\ Next => HonestSingleVote'
        <2>1. ASSUME HonestSingleVote,
                     VotorAction,
                     v \in (Validators \ (ByzantineValidators \cup OfflineValidators))
              PROVE HonestSingleVote'
            BY <2>1 DEF HonestSingleVote, VotorAction

        <2> QED BY <2>1 DEF Next

    <1> QED BY <1>1, <1>2, PTL DEF Spec

\* Byzantine validators cannot break safety even with double voting, considering economic slashing
ByzantineDoubleVoteBounded ==
    \A view \in 1..MaxView :
        LET byzantineVotes == {vote \in votes :
                                vote.sender \in ByzantineValidators /\ vote.view = view}
            effectiveByzantineStake == StakeOfSet({vote.sender : vote \in byzantineVotes}) -
                                     Utils!Sum([v \in {vote.sender : vote \in byzantineVotes} |-> EconomicModel!slashedStake[v]])
        IN effectiveByzantineStake <= (ByzantineFaultBound * TotalStakeSum) \div 100

LEMMA ByzantineCannotForceCertificate ==
    /\ EconomicModel!SlashingCorrectness
    /\ VRFLeaderSelectionDeterminism
    => \A view \in 1..MaxView :
        \A block \in DOMAIN votorVotedBlocks[Validators] :
            LET effectiveByzantineStake == StakeOfSet(ByzantineValidators) -
                                         Utils!Sum([v \in ByzantineValidators |-> EconomicModel!slashedStake[v]])
            IN effectiveByzantineStake < (3 * TotalStakeSum) \div 5 =>
                ~(\E cert \in Certificates : cert.votes \subseteq ByzantineValidators)
PROOF
    <1>1. Economic slashing reduces Byzantine voting power
        BY DEF EconomicModel!SlashValidator, EconomicModel!SlashingAmount
    <1>2. VRF prevents Byzantine leader manipulation
        BY VRFLeaderSelectionDeterminism, VRF!VRFUnpredictabilityProperty
    <1>3. Reduced Byzantine stake insufficient for certificate creation
        BY <1>1, <1>2 DEF StakeOfSet, RequiredStake
    <1> QED BY <1>3

LEMMA EconomicSlashingEnforcement ==
    \A v \in ByzantineValidators :
        \A reason \in {"double_vote", "invalid_cert", "withhold_shreds"} :
            EconomicModel!SlashValidator(v, EconomicModel!SlashingAmount(v, reason), reason) =>
                EconomicModel!slashedStake'[v] > EconomicModel!slashedStake[v]
PROOF
    <1>1. SUFFICES ASSUME NEW v \in ByzantineValidators,
                          NEW reason \in {"double_vote", "invalid_cert", "withhold_shreds"},
                          EconomicModel!SlashValidator(v, EconomicModel!SlashingAmount(v, reason), reason)
                   PROVE EconomicModel!slashedStake'[v] > EconomicModel!slashedStake[v]
        OBVIOUS
    <1>2. EconomicModel!SlashingAmount(v, reason) > 0
        BY DEF EconomicModel!SlashingAmount, EconomicModel!TotalStake
    <1>3. EconomicModel!slashedStake'[v] = EconomicModel!slashedStake[v] + EconomicModel!SlashingAmount(v, reason)
        BY DEF EconomicModel!SlashValidator
    <1> QED BY <1>2, <1>3

----------------------------------------------------------------------------
(* Chain Consistency *)

\* All honest validators have consistent finalized chains
ChainConsistency ==
    \A v1, v2 \in (Validators \ (ByzantineValidators \cup OfflineValidators)) :
        \A slot \in 1..currentSlot :
            /\ Len(votorFinalizedChain[v1]) >= slot
            /\ Len(votorFinalizedChain[v2]) >= slot
            => votorFinalizedChain[v1][slot] = votorFinalizedChain[v2][slot]

THEOREM ChainConsistencyTheorem ==
    Spec => []ChainConsistency
PROOF
    <1>1. []SafetyInvariant => []ChainConsistency
        <2>1. SUFFICES ASSUME SafetyInvariant,
                              NEW v1 \in (Validators \ (ByzantineValidators \cup OfflineValidators)),
                              NEW v2 \in (Validators \ (ByzantineValidators \cup OfflineValidators)),
                              NEW slot \in 1..currentSlot,
                              Len(votorFinalizedChain[v1]) >= slot,
                              Len(votorFinalizedChain[v2]) >= slot
                       PROVE votorFinalizedChain[v1][slot] = votorFinalizedChain[v2][slot]
            BY DEF ChainConsistency

        <2>2. votorFinalizedChain[v1][slot] \in finalizedBlocks[slot]
            BY HonestFinalizationLemma, <2>1

        <2>3. votorFinalizedChain[v2][slot] \in finalizedBlocks[slot]
            BY HonestFinalizationLemma, <2>1

        <2>4. votorFinalizedChain[v1][slot] = votorFinalizedChain[v2][slot]
            BY <2>2, <2>3, SafetyInvariant DEF SafetyInvariant

        <2> QED BY <2>4

    <1> QED BY <1>1, SafetyTheorem

----------------------------------------------------------------------------
(* Byzantine Fault Tolerance *)

\* Safety maintained with up to 20% Byzantine stake, enhanced by economic slashing
ByzantineSafetyResilience ==
    LET effectiveByzantineStake == StakeOfSet(ByzantineValidators) -
                                 Utils!Sum([v \in ByzantineValidators |-> EconomicModel!slashedStake[v]])
    IN effectiveByzantineStake <= TotalStakeSum \div 5 => []SafetyInvariant

THEOREM ByzantineResilienceTheorem ==
    /\ EconomicModel!SlashingCorrectness
    /\ VRFLeaderSelectionDeterminism
    /\ RotorNonEquivocationTheorem
    => LET effectiveByzantineStake == StakeOfSet(ByzantineValidators) -
                                    Utils!Sum([v \in ByzantineValidators |-> EconomicModel!slashedStake[v]])
       IN effectiveByzantineStake <= TotalStakeSum \div 5 => (Spec => []SafetyInvariant)
PROOF
    <1>1. ASSUME LET effectiveByzantineStake == StakeOfSet(ByzantineValidators) -
                                              Utils!Sum([v \in ByzantineValidators |-> EconomicModel!slashedStake[v]])
                 IN effectiveByzantineStake <= TotalStakeSum \div 5
          PROVE (4 * TotalStakeSum) \div 5 > TotalStakeSum - effectiveByzantineStake
        BY <1>1

    <1>2. ASSUME LET effectiveByzantineStake == StakeOfSet(ByzantineValidators) -
                                              Utils!Sum([v \in ByzantineValidators |-> EconomicModel!slashedStake[v]])
                 IN effectiveByzantineStake <= TotalStakeSum \div 5
          PROVE (3 * TotalStakeSum) \div 5 > effectiveByzantineStake
        BY <1>2

    <1>3. Economic slashing reduces Byzantine power over time
        BY EconomicSlashingEnforcement, EconomicModel!SlashingCorrectness

    <1>4. VRF prevents Byzantine leader manipulation
        BY VRFLeaderSelectionDeterminism, VRF!VRFUnpredictabilityProperty

    <1>5. Rotor non-equivocation prevents data withholding attacks
        BY RotorNonEquivocationTheorem

    <1>6. ASSUME LET effectiveByzantineStake == StakeOfSet(ByzantineValidators) -
                                              Utils!Sum([v \in ByzantineValidators |-> EconomicModel!slashedStake[v]])
                 IN effectiveByzantineStake <= TotalStakeSum \div 5
          PROVE ByzantineCannotForceCertificate
        BY <1>2, <1>3, <1>4, <1>5, ByzantineCannotForceCertificate

    <1> QED BY <1>1, <1>2, <1>6, SafetyTheorem

----------------------------------------------------------------------------
(* Boundary Conditions *)

\* Safety at exactly 20% Byzantine threshold
THEOREM ExactThresholdSafety ==
    StakeOfSet(ByzantineValidators) = TotalStakeSum \div 5 => (Spec => []SafetyInvariant)
PROOF
    <1>1. StakeOfSet(ByzantineValidators) = TotalStakeSum \div 5 =>
          StakeOfSet(Validators \ ByzantineValidators) = (4 * TotalStakeSum) \div 5
        BY DEF StakeOfSet, TotalStakeSum

    <1>2. (3 * TotalStakeSum) \div 5 = (3 * ((TotalStakeSum \div 5) * 5)) \div 5
        BY SimpleArithmetic

    <1>3. RequiredStake["fast"] = (4 * TotalStakeSum) \div 5
        BY DEF FastCertificate, RequiredStake

    <1>4. RequiredStake["slow"] = (3 * TotalStakeSum) \div 5
        BY DEF SlowCertificate, RequiredStake

    <1>5. StakeOfSet(ByzantineValidators) <= TotalStakeSum \div 5
        BY <1>1

    <1>6. StakeOfSet(Validators \ ByzantineValidators) >= (3 * TotalStakeSum) \div 5
        BY <1>1, <1>5 DEF StakeOfSet

    <1>7. HonestSingleVoteTheorem
        BY HonestSingleVoteTheorem

    <1> QED BY <1>6, <1>7, SafetyTheorem

\* Safety violation at >20% Byzantine threshold
THEOREM ThresholdViolation ==
    StakeOfSet(ByzantineValidators) > TotalStakeSum \div 5 =>
        \E execution : ~SafetyInvariant
PROOF
    <1>1. ASSUME StakeOfSet(ByzantineValidators) > TotalStakeSum \div 5
          PROVE StakeOfSet(ByzantineValidators) * 3 > (3 * TotalStakeSum) \div 5
        BY <1>1

    <1>2. StakeOfSet(ByzantineValidators) > TotalStakeSum \div 5 =>
          StakeOfSet(ByzantineValidators) * 3 > (3 * TotalStakeSum) \div 5
        BY <1>1

    <1>3. \E slot : \E b1, b2 \in finalizedBlocks'[slot] : b1 # b2
        BY <1>2

    <1> QED BY <1>3 DEF SafetyInvariant

----------------------------------------------------------------------------
(* Helper Lemmas *)

LEMMA HonestFinalizationLemma ==
    \A v \in (Validators \\ (ByzantineValidators \cup OfflineValidators)) :
        \A slot \in 1..Len(votorFinalizedChain[v]) :
            votorFinalizedChain[v][slot] \in finalizedBlocks[slot]
PROOF
    <1>1. SUFFICES ASSUME NEW v \in (Validators \\ (ByzantineValidators \cup OfflineValidators)),
                          NEW slot \in 1..Len(votorFinalizedChain[v])
                   PROVE votorFinalizedChain[v][slot] \in finalizedBlocks[slot]
        BY DEF HonestFinalizationLemma

    <1>2. votorFinalizedChain[v] \in Seq(Types!Block)
        BY DEF votorFinalizedChain

    <1>3. \E cert \in Certificates :
          /\ cert.slot = slot
          /\ cert.block = votorFinalizedChain[v][slot].hash
          /\ (FastCertificate(cert) \/ SlowCertificate(cert))
        BY <1>2 DEF Votor!FinalizeBlock

    <1>4. votorFinalizedChain[v][slot] \in finalizedBlocks[slot]
        BY <1>3 DEF finalizedBlocks

    <1> QED BY <1>4

LEMMA RequiredStakeForType ==
    /\ (4 * TotalStakeSum) \div 5 \in Nat  \* Fast path
    /\ (3 * TotalStakeSum) \div 5 \in Nat  \* Slow path
    /\ (3 * TotalStakeSum) \div 5 \in Nat  \* Skip
PROOF
    <1>1. TotalStakeSum \in Nat
        BY DEF StakeOfSetSum, Stake

    <1>2. \A n \in Nat : (4 * n) \div 5 \in Nat
        BY SimpleArithmetic

    <1>3. \A n \in Nat : (3 * n) \div 5 \in Nat
        BY SimpleArithmetic

    <1> QED BY <1>1, <1>2, <1>3

LEMMA PigeonholePrinciple ==
    \A S1, S2 \in SUBSET Validators :
        StakeOfSet(S1) + StakeOfSet(S2) > TotalStakeSum =>
            S1 \cap S2 # {}
PROOF
    <1>1. SUFFICES ASSUME NEW S1 \in SUBSET Validators,
                          NEW S2 \in SUBSET Validators,
                          StakeOfSet(S1) + StakeOfSet(S2) > TotalStakeSum
                   PROVE S1 \cap S2 # {}
        BY DEF PigeonholePrinciple
    <1>2. ASSUME S1 \cap S2 = {}
          PROVE StakeOfSet(S1 \cup S2) = StakeOfSet(S1) + StakeOfSet(S2)
        BY <1>2 DEF StakeOfSet
    <1>3. S1 \cup S2 \subseteq Validators
        BY <1>1
    <1>4. StakeOfSet(S1 \cup S2) <= TotalStakeSum
        BY <1>3 DEF TotalStakeSum, StakeOfSet
    <1>5. StakeOfSet(S1) + StakeOfSet(S2) <= TotalStakeSum
        BY <1>2, <1>4
    <1>6. FALSE
        BY <1>1, <1>5
    <1> QED BY <1>6

LEMMA CryptographicIntegrity ==
    \A v \in (Validators \ ByzantineValidators) :
        \A shred1, shred2 \in UNION {Rotor!blockShreds[b][v] : b \in DOMAIN Rotor!blockShreds} :
            /\ shred1.slot = shred2.slot
            /\ shred1.index = shred2.index
            => shred1 = shred2
PROOF
    <1>1. Honest validators use cryptographic signatures
        BY DEF Types!Shred, Crypto!Sign
    <1>2. Cryptographic signatures prevent forgery
        BY CryptographicAssumptions
    <1>3. Same slot and index with honest validator implies same shred
        BY <1>1, <1>2
    <1> QED BY <1>3

LEMMA VRFLeaderWindowSafety ==
    \A slot \in 1..MaxSlot, view1, view2 \in 1..MaxView, validators \in SUBSET Validators, stakeMap \in [Validators -> Nat] :
        LET windowIndex == slot \div LeaderWindowSize
            leader1 == VRF!VRFIsLeaderForView(CHOOSE v \in validators : TRUE, slot, view1, validators, stakeMap, LeaderWindowSize)
            leader2 == VRF!VRFIsLeaderForView(CHOOSE v \in validators : TRUE, slot, view2, validators, stakeMap, LeaderWindowSize)
        IN view1 = view2 => leader1 = leader2
PROOF
    <1>1. VRF!VRFIsLeaderForView is deterministic for same view
        BY DEF VRF!VRFIsLeaderForView, VRF!VRFComputeWindowLeader, VRF!VRFRotateLeaderInWindow
    <1>2. Same view implies same leader rotation
        BY <1>1, VRFLeaderSelectionDeterminism
    <1> QED BY <1>2

LEMMA HonestMajorityAssumption ==
    StakeOfSet(Validators \ ByzantineValidators) > StakeOfSet(ByzantineValidators)
PROOF
    <1>1. StakeOfSet(ByzantineValidators) <= TotalStakeSum \div 5
        BY ByzantineAssumption

    <1>2. StakeOfSet(Validators \ ByzantineValidators) =
          TotalStakeSum - StakeOfSet(ByzantineValidators)
        BY DEF StakeOfSet, TotalStakeSum

    <1>3. TotalStakeSum - TotalStakeSum \div 5 = (4 * TotalStakeSum) \div 5
        BY SimpleArithmetic

    <1>4. StakeOfSet(Validators \ ByzantineValidators) >= (4 * TotalStakeSum) \div 5
        BY <1>1, <1>2, <1>3

    <1>5. (4 * TotalStakeSum) \div 5 > TotalStakeSum \div 5
        BY TotalStakeSum > 0

    <1> QED BY <1>1, <1>4, <1>5

============================================================================
