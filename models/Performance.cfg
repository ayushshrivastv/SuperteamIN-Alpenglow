\* Performance testing configuration for Alpenglow protocol
\* Focus on throughput, latency, and scalability metrics
\* Integrates with Integration.tla performance metrics tracking

SPECIFICATION SpecIntegration

CONSTANTS
    \* Moderate validator set for performance analysis
    Validators = {v1, v2, v3, v4, v5, v6, v7, v8, v9, v10,
                  v11, v12, v13, v14, v15}
    LeaderFunction(v, Vals) == CHOOSE x \in Vals : x = Vals[((v-1) % Cardinality(Vals)) + 1]  \* Round-robin
    
    \* Minimal faults for performance baseline
    ByzantineValidators = {v14, v15}    \* ~13% Byzantine
    OfflineValidators = {v13}           \* ~7% Offline
    
    \* Performance testing parameters
    MaxSlot = 25                        \* Extended for better metrics
    MaxView = 20                        \* Allow more view changes
    MaxTime = 100                       \* Longer execution for stable metrics
    
    \* Optimized network parameters for performance testing
    GST = 3
    Delta = 1                           \* Low latency for performance testing
    MaxMessageSize = 4096
    NetworkCapacity = 250000            \* Increased capacity for throughput testing
    MaxBufferSize = 300                 \* Larger buffers for high throughput
    PartitionTimeout = 5
    
    \* Erasure coding optimized for performance
    K = 8
    N = 12
    MaxBlocks = 75                      \* Higher throughput target
    BandwidthLimit = 150000             \* Increased bandwidth limit
    RetryTimeout = 2
    MaxRetries = 3                      \* Allow more retries for reliability
    
    \* Block and transaction throughput parameters
    MaxBlockSize = 6000                 \* Larger blocks for throughput testing
    BandwidthPerValidator = 12000       \* Higher per-validator bandwidth
    MaxTransactions = 750               \* More transactions per block
    
    \* Protocol parameters optimized for speed
    TimeoutDelta = 3
    InitialLeader = v1
    FastPathStake = 80                  \* Usually achievable
    SlowPathStake = 60
    SkipPathStake = 60
    
    \* Cryptographic parameters
    MaxSignatures = 150
    MaxCertificates = 150

\* Performance-focused constraints with Integration.tla metrics
CONSTRAINT StateConstraint
STATE_CONSTRAINT
    /\ currentSlot <= MaxSlot
    /\ clock <= MaxTime
    /\ \A v \in Validators : votorView[v] <= MaxView
    /\ Cardinality(messages) <= 15000
    /\ Cardinality(certificates) <= MaxCertificates
    \* Integration.tla performance bounds
    /\ performanceMetrics.throughput <= MaxBlockSize * N
    /\ performanceMetrics.latency >= Delta
    /\ performanceMetrics.bandwidth <= NetworkCapacity
    /\ performanceMetrics.certificateRate <= MaxSlot
    /\ performanceMetrics.repairRate <= MaxBlocks * MaxRetries

\* Core properties for performance
INVARIANT TypeOK
INVARIANT Safety
INVARIANT ChainConsistency
INVARIANT TypeInvariantIntegration
INVARIANT ComponentConsistency
INVARIANT CrossComponentSafety
INVARIANT PerformanceBounds

\* Performance properties from Integration.tla
PROPERTY Liveness
PROPERTY FastPath
PROPERTY BoundedFinalization
PROPERTY EventuallyRunning
PROPERTY RecoveryProperty
PROPERTY NoPermamentFailure
PROPERTY CrossComponentLiveness
PROPERTY IntegrationEfficiency

\* Enhanced throughput analysis using Integration.tla metrics
ThroughputAnalysis ==
    /\ performanceMetrics.throughput > 0
    /\ LET FinalizedCount == Cardinality(finalizedBlocks)
           TimeElapsed == IF clock > 0 THEN clock ELSE 1
           ExpectedThroughput == MaxBlockSize \div (2 * Delta)
       IN /\ FinalizedCount >= TimeElapsed \div 3  \* Conservative baseline
          /\ performanceMetrics.throughput >= ExpectedThroughput \div 2

\* Latency analysis with Integration.tla metrics
LatencyAnalysis ==
    /\ performanceMetrics.latency >= Delta
    /\ performanceMetrics.latency <= 5 * Delta  \* Reasonable upper bound
    /\ \A block \in finalizedBlocks :
        \E t \in Delta..(3*Delta) : 
            block.timestamp + t >= finalizationTime[block]

\* Bandwidth utilization analysis
BandwidthAnalysis ==
    /\ performanceMetrics.bandwidth <= NetworkCapacity
    /\ performanceMetrics.bandwidth >= NetworkCapacity \div 10  \* Minimum utilization
    /\ LET UtilizationRatio == performanceMetrics.bandwidth * 100 \div NetworkCapacity
       IN UtilizationRatio >= 10 /\ UtilizationRatio <= 90  \* Healthy range

\* Certificate generation efficiency
CertificateEfficiency ==
    /\ performanceMetrics.certificateRate > 0
    /\ performanceMetrics.certificateRate <= MaxSlot
    /\ LET FastCerts == {cert \in certificates : cert.type = "fast"}
           SlowCerts == {cert \in certificates : cert.type = "slow"}
           FastRatio == IF Cardinality(certificates) > 0 
                       THEN Cardinality(FastCerts) * 100 \div Cardinality(certificates)
                       ELSE 0
       IN FastRatio >= 60  \* Prefer fast path

\* Repair rate analysis for network health
RepairRateAnalysis ==
    /\ performanceMetrics.repairRate <= MaxBlocks \div 2  \* Reasonable repair rate
    /\ LET RepairRatio == IF MaxBlocks > 0 
                         THEN performanceMetrics.repairRate * 100 \div MaxBlocks
                         ELSE 0
       IN RepairRatio <= 25  \* Keep repairs under 25%

\* Component health performance impact
ComponentHealthPerformance ==
    /\ systemState = "running" => 
        /\ performanceMetrics.throughput >= MaxBlockSize \div (3 * Delta)
        /\ performanceMetrics.latency <= 4 * Delta
    /\ componentHealth.votor = "degraded" =>
        performanceMetrics.throughput <= performanceMetrics.throughput * 2
    /\ componentHealth.network = "congested" =>
        performanceMetrics.bandwidth >= NetworkCapacity * 3 \div 4
    /\ componentHealth.rotor = "degraded" =>
        performanceMetrics.repairRate >= MaxBlocks \div 4

\* Cross-component performance consistency
CrossComponentPerformance ==
    /\ systemState = "running" =>
        /\ \E interaction \in interactionLog :
            /\ interaction.source = "votor" 
            /\ interaction.target = "rotor"
            /\ interaction.timestamp <= clock
        /\ performanceMetrics.certificateRate > 0
        /\ performanceMetrics.throughput > 0

\* Performance degradation bounds
PerformanceDegradationBounds ==
    /\ componentHealth.network = "partitioned" =>
        performanceMetrics.throughput <= performanceMetrics.throughput \div 2
    /\ componentHealth.rotor = "failed" =>
        performanceMetrics.repairRate > MaxBlocks \div 2
    /\ Cardinality(integrationErrors) > 0 =>
        systemState \in {"degraded", "recovering", "halted"}

\* Enhanced performance metrics view with Integration.tla data
VIEW <<currentSlot, 
       clock,
       systemState,
       performanceMetrics.throughput,
       performanceMetrics.latency,
       performanceMetrics.bandwidth,
       performanceMetrics.certificateRate,
       performanceMetrics.repairRate,
       Cardinality(finalizedBlocks),
       Cardinality(certificates),
       Cardinality({c \in certificates : c.type = "fast"}),
       Cardinality(integrationErrors),
       componentHealth.votor,
       componentHealth.rotor,
       componentHealth.network>>

\* Action constraints for performance with Integration.tla awareness
ACTION_CONSTRAINT PerformanceConstraint
ACTION_CONSTRAINT
    /\ Cardinality({msg \in networkMessages : msg.type = "block"}) <= MaxBlocks
    /\ Cardinality({msg \in networkMessages : msg.type = "vote"}) <= MaxSignatures
    /\ Cardinality(interactionLog) <= 1000  \* Limit interaction log size
    /\ LET BandwidthUsage == performanceMetrics.bandwidth
       IN BandwidthUsage <= NetworkCapacity * 95 \div 100  \* 95% capacity limit

\* Performance-specific properties to verify
PROPERTY ThroughputAnalysis
PROPERTY LatencyAnalysis  
PROPERTY BandwidthAnalysis
PROPERTY CertificateEfficiency
PROPERTY RepairRateAnalysis
PROPERTY ComponentHealthPerformance
PROPERTY CrossComponentPerformance
PROPERTY PerformanceDegradationBounds

\* Initial state using Integration.tla initialization
INIT InitIntegration

\* Next-state relation using Integration.tla transitions
NEXT NextIntegration

\* Symmetry for performance (exclude faulty validators)
\* v13 is offline, v14, v15 are Byzantine
\* Only include honest validators for symmetry reduction
SYMMETRY Permutations({v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12})

\* Performance benchmarking aliases
ALIAS ThroughputBenchmark == performanceMetrics.throughput
ALIAS LatencyBenchmark == performanceMetrics.latency
ALIAS BandwidthBenchmark == performanceMetrics.bandwidth
ALIAS CertificateRateBenchmark == performanceMetrics.certificateRate
ALIAS RepairRateBenchmark == performanceMetrics.repairRate
ALIAS SystemHealthBenchmark == systemState
ALIAS ComponentHealthBenchmark == componentHealth
ALIAS FinalizationRateBenchmark == Cardinality(finalizedBlocks) * 100 \div MaxSlot
ALIAS FastPathRatioBenchmark == IF Cardinality(certificates) > 0 
                                THEN Cardinality({c \in certificates : c.type = "fast"}) * 100 \div Cardinality(certificates)
                                ELSE 0
