\* Adversarial Configuration for Alpenglow Protocol
\* Tests sophisticated adversarial scenarios including coordinated Byzantine attacks,
\* eclipse attacks, and adaptive adversaries as described in the whitepaper

SPECIFICATION Spec

CONSTANTS
    \* Validator set designed for adversarial testing
    Validators = {v1, v2, v3, v4, v5, v6}  \* 6 validators for complex scenarios
    
    \* Byzantine validators controlling just under 20% stake (whitepaper limit)
    ByzantineValidators = {v6}  \* Single coordinated adversary
    
    \* Additional validators that may crash (up to 20% more under Assumption 2)
    OfflineValidators = {v5}  \* Simulates crash faults
    
    \* Stake distribution for adversarial scenarios
    \* Byzantine: 19%, Crashed: 15%, Correct: 66% (meets Assumption 2)
    Stake = [v1 |-> 25, v2 |-> 20, v3 |-> 15, v4 |-> 6, v5 |-> 15, v6 |-> 19]
    
    \* Extended slot range for complex attack sequences
    MaxSlot = 8
    
    \* High view changes to test view-change attacks
    MaxView = 20
    
    \* Network parameters for adversarial conditions
    GST = 100  \* Very late stabilization (adversary controls network initially)
    Delta = 25  \* High network delay under attack
    
    \* Erasure coding parameters for Rotor attacks
    K = 32   \* Minimum shreds needed (γ in whitepaper)
    N = 64   \* Total shreds sent (Γ in whitepaper) - 2x expansion
    
    \* Timeout parameters for adaptive adversary
    TimeoutDelta = 50  \* Large timeout to test timeout manipulation
    
    \* Block and bandwidth parameters for throughput attacks
    MaxBlockSize = 8  \* Larger blocks for bandwidth exhaustion attacks
    BandwidthPerValidator = 50  \* Higher bandwidth for realistic attack scenarios
    MaxMessageSize = 4  \* Larger messages for message flooding attacks
    NetworkCapacity = 300  \* Higher capacity to test sophisticated attacks
    
    \* Leader selection for coordinated attacks
    LeaderFunction(v, Vals) == 
        IF v6 \in Vals THEN v6  \* Byzantine leader when possible
        ELSE CHOOSE x \in Vals : TRUE
    
    \* Eclipse attack parameters
    EclipseTargets = {v1, v2}  \* Targets for eclipse attacks
    EclipseAttacker = v6  \* Adversary performing eclipse
    
    \* Adaptive adversary parameters
    AdaptiveThreshold = 3  \* Slots before adversary adapts strategy
    AttackPhases = 3  \* Number of different attack phases
    
    \* Coordinated attack parameters
    CoordinationDelay = 5  \* Delay for coordinated Byzantine actions
    AttackWindow = 4  \* Window size for coordinated attacks
    
    \* Advanced attack vectors from whitepaper
    EquivocationEnabled = TRUE  \* Test block equivocation attacks
    WithholdingEnabled = TRUE   \* Test vote/block withholding
    TimingAttackEnabled = TRUE  \* Test timing-based attacks
    PartitionAttackEnabled = TRUE  \* Test network partition attacks

\* Safety properties that must hold even under adversarial conditions
INVARIANT TypeOK
INVARIANT Safety
INVARIANT NoEquivocation  \* No honest validator signs conflicting blocks
INVARIANT ByzantineStakeLimit  \* Byzantine stake < 20%
INVARIANT CorrectStakeMajority  \* Correct stake > 60% under Assumption 2

\* Liveness properties to test under adversarial conditions
PROPERTY Progress  \* System makes progress despite attacks
PROPERTY EventualFinalization  \* Blocks eventually finalize after GST
PROPERTY AdversarialResilience  \* System recovers from coordinated attacks

\* Advanced adversarial invariants
INVARIANT NoSuccessfulEclipse  \* Eclipse attacks don't compromise safety
INVARIANT AdaptiveAttackResilience  \* System handles adaptive strategies
INVARIANT CoordinatedAttackResilience  \* System survives coordinated Byzantine behavior

\* State space constraints for adversarial model checking
CONSTRAINT
    /\ currentSlot <= MaxSlot
    /\ clock <= 500  \* Extended time for complex attack sequences
    /\ Cardinality(messages) <= 200  \* Higher message limit for attack scenarios
    /\ Cardinality(byzantineActions) <= 100  \* Track Byzantine actions
    /\ attackPhase <= AttackPhases  \* Limit attack phase transitions

\* Specific adversarial scenarios to test
CONSTRAINT AdversarialScenarios ==
    \* Scenario 1: Coordinated Byzantine attack at protocol start
    \/ /\ currentSlot <= 2
       /\ byzantineCoordination = TRUE
    
    \* Scenario 2: Eclipse attack during leader transition
    \/ /\ currentSlot \in 3..5
       /\ eclipseActive = TRUE
       /\ leaderTransition = TRUE
    
    \* Scenario 3: Adaptive adversary changing strategy
    \/ /\ currentSlot \in 6..8
       /\ adaptiveStrategy = TRUE
       /\ attackPhase > 1
    
    \* Scenario 4: Network partition with Byzantine leader
    \/ /\ currentSlot >= 4
       /\ networkPartitioned = TRUE
       /\ leader(currentSlot) = v6

\* Attack-specific constraints from whitepaper analysis
CONSTRAINT WhitepaperAttackVectors ==
    \* Test "20+20" resilience model
    /\ ByzantineStake < 20
    /\ CrashedStake <= 20
    /\ CorrectStake >= 60
    
    \* Test Rotor attack resilience (Section 2.2)
    /\ rotorAttackMitigation = TRUE
    
    \* Test Votor attack resilience (Section 2.6)
    /\ votorAttackMitigation = TRUE
    
    \* Test fast vs slow path attacks
    /\ fastPathAttackTested = TRUE
    /\ slowPathAttackTested = TRUE

\* Performance under attack constraints
CONSTRAINT PerformanceUnderAttack ==
    \* Ensure system doesn't degrade beyond acceptable limits
    /\ finalizationLatency <= 10 * Delta  \* Max 10x normal latency
    /\ throughputDegradation <= 50  \* Max 50% throughput loss
    /\ bandwidthAmplification <= 5  \* Max 5x bandwidth usage

\* Initialize with adversarial conditions
INIT InitAdversarial

\* Next state with adversarial actions
NEXT NextAdversarial

\* Fairness constraints for adversarial testing
FAIRNESS
    \* Ensure Byzantine validators eventually act
    /\ \A v \in ByzantineValidators : WF_vars(ByzantineAction(v))
    
    \* Ensure network eventually stabilizes (GST model)
    /\ WF_vars(NetworkStabilization)
    
    \* Ensure adaptive adversary eventually changes strategy
    /\ WF_vars(AdaptiveStrategyChange)
    
    \* Ensure coordinated attacks eventually execute
    /\ WF_vars(CoordinatedAttack)

\* Temporal properties for adversarial resilience
TEMPORAL AdversarialTemporalProperties ==
    \* Safety always holds despite attacks
    /\ []Safety
    
    \* Progress eventually resumes after attacks
    /\ [](AttackActive ~> <>Progress)
    
    \* System recovers from Byzantine coordination
    /\ [](CoordinatedAttack ~> <>SystemRecovery)
    
    \* Eclipse attacks don't permanently partition network
    /\ [](EclipseActive ~> <>NetworkConnected)
    
    \* Adaptive attacks don't break fundamental properties
    /\ [](AdaptiveAttack ~> <>ProtocolStability)

\* Model checking directives for adversarial scenarios
CHECK AdversarialSafety == []Safety
CHECK AdversarialLiveness == <>[]Progress
CHECK ByzantineResilience == [](ByzantineAction ~> <>SystemStable)
CHECK EclipseResilience == [](EclipseAttack ~> <>NetworkHealed)
CHECK AdaptiveResilience == [](AdaptiveStrategy ~> <>CounterStrategy)