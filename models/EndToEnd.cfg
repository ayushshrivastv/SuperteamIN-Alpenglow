\* Comprehensive End-to-End Configuration for Alpenglow Protocol
\* Tests complete integration of all components with fixed symbol references
\* and deterministic behavior for full formal verification

SPECIFICATION Spec

\* ============================================================================
\* VALIDATOR CONFIGURATION
\* ============================================================================

CONSTANTS
    \* Define model values for validators
    v1 = v1
    v2 = v2  
    v3 = v3
    v4 = v4
    v5 = v5
    
    \* Validator sets for comprehensive testing
    Validators = {v1, v2, v3, v4, v5}
    ByzantineValidators = {v5}  \* 20% Byzantine (1 out of 5)
    OfflineValidators = {v4}    \* 20% Offline (1 out of 5)
    TotalStake = 50
    
    \* Stake thresholds (fixed values based on total stake)
    FastPathStake = 40      \* 80% of total stake (40/50)
    SlowPathStake = 30      \* 60% of total stake (30/50)
    SkipPathStake = 30      \* 60% of total stake (30/50)

\* ============================================================================
\* PROTOCOL PARAMETERS
\* ============================================================================

CONSTANTS
    \* Slot and view limits for comprehensive testing
    MaxSlot = 10
    MaxView = 8
    MaxTime = 200
    
    \* Network timing parameters
    GST = 20                \* Global Stabilization Time
    Delta = 5               \* Network delay bound after GST
    SlotDuration = 15       \* Slot duration in time units
    
    \* Timeout configuration
    TimeoutDelta = 10       \* Base timeout for view changes
    InitialLeader = v1      \* Deterministic initial leader
    
    \* Block and transaction limits
    MaxBlockSize = 1000
    MaxTransactions = 20
    BandwidthPerValidator = 2000

\* ============================================================================
\* ROTOR (ERASURE CODING) PARAMETERS
\* ============================================================================

CONSTANTS
    \* Erasure coding configuration
    K = 3                   \* Data shreds required for reconstruction
    N = 5                   \* Total shreds (data + parity)
    MaxBlocks = 15          \* Maximum blocks in system
    
    \* Bandwidth and retry configuration
    BandwidthLimit = 10000  \* Total bandwidth limit
    RetryTimeout = 8        \* Timeout for repair requests
    MaxRetries = 3          \* Maximum repair attempts
    
    \* Performance thresholds
    LowLatencyThreshold = 50
    HighLatencyThreshold = 150
    LoadBalanceTolerance = 3

\* ============================================================================
\* NETWORK PARAMETERS
\* ============================================================================

CONSTANTS
    \* Network capacity and buffering
    NetworkCapacity = 5000  \* Total network capacity
    MaxBufferSize = 100     \* Per-validator buffer size
    MaxMessageSize = 500    \* Maximum message size
    
    \* Partition and recovery parameters
    PartitionTimeout = 25   \* Timeout for partition detection
    RecoveryTimeout = 30    \* Timeout for partition recovery
    MessageDelay = 2        \* Base message delay
    
    \* Network fault parameters
    MaxNetworkDelay = 8     \* Maximum network delay
    MessageLossRate = 0     \* Message loss rate (0 for deterministic testing)
    MaxNetworkPartitions = 2 \* Maximum concurrent partitions
    MaxRetransmissions = 4  \* Maximum message retransmissions

\* ============================================================================
\* CRYPTOGRAPHIC PARAMETERS
\* ============================================================================

CONSTANTS
    \* Signature and certificate limits
    MaxSignatures = 50      \* Maximum signatures in system
    MaxCertificates = 25    \* Maximum certificates per view
    
    \* Cryptographic abstractions
    MaxAggregatedSignatures = 20
    MaxVRFProofs = 15

\* ============================================================================
\* DETERMINISTIC LEADER SELECTION
\* ============================================================================

CONSTANTS
    \* Deterministic stake-weighted leader function
    LeaderFunction = [
        slot \in 1..MaxSlot, vals \in SUBSET Validators |-> 
        IF vals = {} THEN v1
        ELSE LET totalStake == 50
                 \* VRF-style deterministic selection based on slot
                 vrfSeed == (slot * 997 + 991) % 1000000
                 targetValue == vrfSeed % totalStake
                 \* Cumulative stake calculation
                 orderedVals == {v1, v2, v3, v4, v5} \cap vals
                 cumulativeStake == [v \in orderedVals |-> 
                     IF v = v1 THEN Stake[v1]
                     ELSE IF v = v2 THEN Stake[v1] + Stake[v2]  
                     ELSE IF v = v3 THEN Stake[v1] + Stake[v2] + Stake[v3]
                     ELSE IF v = v4 THEN Stake[v1] + Stake[v2] + Stake[v3] + Stake[v4]
                     ELSE Stake[v1] + Stake[v2] + Stake[v3] + Stake[v4] + Stake[v5]
                 ]
             IN CHOOSE v \in orderedVals :
                 /\ cumulativeStake[v] > targetValue
                 /\ \A u \in orderedVals : 
                     (u \in {v1, v2, v3, v4} /\ u < v) => cumulativeStake[u] <= targetValue
    ]

\* ============================================================================
\* INTEGRATION PARAMETERS
\* ============================================================================

CONSTANTS
    \* Integration testing parameters
    MaxIntegrationErrors = 10
    MaxInteractionLogSize = 100
    PerformanceMetricWindow = 20
    
    \* Component health thresholds
    HealthCheckInterval = 5
    DegradationThreshold = 3
    RecoveryThreshold = 2

\* ============================================================================
\* STATE CONSTRAINTS FOR BOUNDED MODEL CHECKING
\* ============================================================================

\* Primary state constraint to prevent state explosion
CONSTRAINT
    /\ clock <= MaxTime
    /\ currentSlot <= MaxSlot
    /\ \A v \in Validators : votorView[v] <= MaxView
    /\ Cardinality(messages) <= 200
    /\ \A vw \in 1..MaxView : Cardinality(votorGeneratedCerts[vw]) <= MaxCertificates
    \* Prevent symbol mismatch issues by ensuring proper domains
    /\ \A v \in Validators : v \in DOMAIN votorView
    /\ \A v \in Validators : v \in DOMAIN Stake
    /\ DOMAIN votorGeneratedCerts \subseteq 1..MaxView
    \* Ensure certificate references are valid
    /\ LET allCerts == UNION {votorGeneratedCerts[vw] : vw \in 1..MaxView}
       IN Cardinality(allCerts) <= MaxCertificates * MaxView
    \* Network constraints
    /\ Cardinality(networkMessageQueue) <= NetworkCapacity \div 10
    /\ \A v \in Validators : Cardinality(networkMessageBuffer[v]) <= MaxBufferSize
    /\ Cardinality(networkPartitions) <= MaxNetworkPartitions
    \* Rotor constraints
    /\ Cardinality(DOMAIN rotorBlockShreds) <= MaxBlocks
    /\ \A v \in Validators : Cardinality(rotorReceivedShreds[v]) <= N * MaxBlocks
    /\ \A v \in Validators : rotorBandwidthUsage[v] <= BandwidthLimit
    \* Integration constraints
    /\ Cardinality(deliveredBlocks) <= MaxBlocks
    /\ \A slot \in 1..MaxSlot : Cardinality(finalizedBlocks[slot]) <= 1

\* ============================================================================
\* ACTION CONSTRAINTS FOR DETERMINISTIC BEHAVIOR
\* ============================================================================

\* Action constraints (inline with CONSTRAINT)
CONSTRAINT ActionConstraint
    /\ clock' <= MaxTime
    /\ currentSlot' <= MaxSlot
    /\ \A v \in Validators : votorView'[v] <= MaxView
    /\ Cardinality(messages') <= 250
    /\ \A vw \in 1..MaxView : Cardinality(votorGeneratedCerts'[vw]) <= MaxCertificates
    \* Ensure deterministic leader selection
    /\ \A slot \in 1..MaxSlot : 
        \A vals \in SUBSET Validators :
            LeaderFunction[slot, vals] \in vals \cup {v1}
    \* Bound Byzantine behavior
    /\ \A v \in ByzantineValidators :
        Cardinality({msg \in messages' : msg.sender = v}) <= 10 * currentSlot'
    \* Network action bounds
    /\ Cardinality(networkMessageQueue') <= NetworkCapacity \div 8
    /\ networkDroppedMessages' <= networkDroppedMessages + 5
    \* Rotor action bounds
    /\ \A v \in Validators : rotorBandwidthUsage'[v] <= BandwidthLimit
    /\ Cardinality({req \in rotorRepairRequests'[v] : v \in Validators}) <= MaxBlocks * MaxRetries

\* ============================================================================
\* INVARIANTS TO VERIFY
\* ============================================================================

\* Core type safety
INVARIANT TypeOK

\* Safety properties with corrected certificate references
INVARIANT Safety
INVARIANT HonestVoteUniqueness  
INVARIANT ChainConsistency
INVARIANT ConsistentFinalization

\* Certificate uniqueness using proper symbol references
INVARIANT CertificateUniqueness

\* Stake threshold validation (removed - not defined)
\* INVARIANT ValidStakeThresholds

\* Integration safety
INVARIANT CrossComponentSafety
INVARIANT ComponentConsistency

\* Network integrity
INVARIANT MessageIntegrity
INVARIANT MessageAuthenticity

\* Byzantine resilience
INVARIANT ByzantineResilience

\* ============================================================================
\* LIVENESS PROPERTIES TO VERIFY
\* ============================================================================

\* Progress properties
PROPERTY Progress
PROPERTY EventualFinalization
PROPERTY VoteAggregation

\* Fast path completion
PROPERTY FastPath

\* Bounded finalization time
PROPERTY BoundedFinalization

\* Recovery properties
PROPERTY PartitionRecovery
PROPERTY SystemRecovery

\* Integration liveness
PROPERTY RotorVotorIntegration
PROPERTY NetworkDependentProgress
PROPERTY CrossComponentLiveness

\* ============================================================================
\* RESILIENCE PROPERTIES
\* ============================================================================

\* Combined 20+20 resilience theorem
PROPERTY Combined2020Resilience

\* Offline resilience
PROPERTY OfflineResilience

\* Network partition tolerance
PROPERTY PartitionResilience

\* Performance under stress
PROPERTY GracefulPerformanceDegradation

\* ============================================================================
\* SYMMETRY REDUCTION
\* ============================================================================

\* Symmetry reduction (commented out for TLC compatibility)
\* SYMMETRY Permutations({v2, v3})

\* ============================================================================
\* INITIAL STATE AND NEXT RELATION
\* ============================================================================

\* Initial state predicate
INIT Init

\* Next-state relation with all component actions
NEXT Next

\* ============================================================================
\* VIEW FOR STATE SPACE EXPLORATION
\* ============================================================================

\* Enhanced view for better state space exploration and debugging
VIEW <<
    currentSlot, 
    clock,
    [v \in Validators |-> votorView[v]], 
    [v \in Validators |-> Cardinality(votorFinalizedChain[v])],
    Cardinality(UNION {votorGeneratedCerts[vw] : vw \in 1..MaxView}),
    Cardinality(deliveredBlocks),
    Cardinality(messages),
    Cardinality(networkPartitions),
    [v \in Validators |-> failureStates[v]]
>>

\* ============================================================================
\* STRESS TESTING SCENARIOS
\* ============================================================================

\* Enable Byzantine behavior for stress testing
CONSTRAINT ByzantineStressTest
    \* Allow Byzantine validators to send conflicting messages
    /\ \A v \in ByzantineValidators :
        Cardinality({msg \in messages : msg.sender = v /\ msg.type = "vote"}) <= 20
    \* Allow network partitions for resilience testing
    /\ Cardinality(networkPartitions) <= 1
    \* Allow temporary offline behavior
    /\ \A v \in OfflineValidators :
        failureStates[v] \in {"offline", "active"}

\* ============================================================================
\* PERFORMANCE OPTIMIZATION
\* ============================================================================

\* Fingerprint for state space reduction
ALIAS Fingerprint == <<
    currentSlot,
    [v \in Validators |-> votorView[v]],
    Cardinality(UNION {votorGeneratedCerts[vw] : vw \in 1..MaxView}),
    Cardinality(finalizedBlocks[currentSlot])
>>

\* ============================================================================
\* VERIFICATION TARGETS
\* ============================================================================

\* This configuration verifies:
\* 1. Complete end-to-end protocol correctness
\* 2. Integration between Votor, Rotor, and Network components  
\* 3. Byzantine fault tolerance (20% Byzantine validators)
\* 4. Offline fault tolerance (20% offline validators)
\* 5. Network partition resilience
\* 6. Deterministic leader selection
\* 7. Proper certificate generation and propagation
\* 8. Bounded finalization times
\* 9. Performance under stress conditions
\* 10. Recovery from failures and partitions
