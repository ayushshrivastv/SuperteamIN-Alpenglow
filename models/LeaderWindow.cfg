\* Author: Ayush Srivastava
\* TLC Model Configuration for Leader Window Testing
\* Tests 4-slot leader windows with VRF-based leader selection
\* Configured for small state space to avoid explosion while ensuring
\* comprehensive testing of window transitions and VRF determinism

SPECIFICATION Spec

CONSTANTS
    \* Core validator set - 3 validators for manageable state space
    Validators = {v1, v2, v3}
    
    \* Byzantine and offline validators for fault testing
    ByzantineValidators = {v3}
    OfflineValidators = {}
    
    \* Leader window configuration
    LeaderWindowSize = 4
    
    \* Slot configuration - 12 slots = exactly 3 complete windows
    MaxSlot = 12
    MaxView = 8
    MaxTime = 200
    
    \* Network timing parameters
    GST = 10
    Delta = 5
    TimeoutDelta = 20
    
    \* Initial leader for deterministic testing
    InitialLeader = v1
    
    \* Erasure coding parameters (small for testing)
    K = 2
    N = 3
    
    \* Resource limits for model checking
    MaxBlockSize = 100
    BandwidthPerValidator = 1000
    MaxMessageSize = 50
    NetworkCapacity = 5000
    BandwidthLimit = 1500
    MaxRetries = 3
    
    \* VRF configuration for deterministic leader selection
    VRFKeyPairs = {
        [validator |-> v1, publicKey |-> 12345, privateKey |-> 6172, valid |-> TRUE],
        [validator |-> v2, publicKey |-> 23456, privateKey |-> 11728, valid |-> TRUE],
        [validator |-> v3, publicKey |-> 34567, privateKey |-> 17283, valid |-> TRUE]
    }
    MaxVRFOutput = 10000
    VRFSeed = 42

INIT Init
NEXT Next

INVARIANTS
    \* Core type safety
    TypeOK
    
    \* Safety properties
    Safety
    CertificateUniqueness
    ChainConsistency
    ConsistentFinalization
    
    \* VRF-specific invariants for leader window testing
    VRFProofsValid
    VRFLeaderScheduleDeterministic
    VRFCryptographicProperties
    
    \* Leader window consistency invariants
    LeaderWindowConsistency
    VRFDeterminism
    
    \* Delivered blocks consistency
    DeliveredBlocksConsistency
    DeliveredBlocksValidity

PROPERTIES
    \* Progress and liveness
    Progress
    FastPath
    BoundedFinalization
    
    \* Resilience properties
    ByzantineResilience
    PartitionRecovery
    
    \* VRF liveness properties
    VRFLivenessProperties
    
    \* Leader window specific properties
    LeaderWindowProgress
    WindowTransitionLiveness

CONSTRAINTS
    \* State space constraints for model checking
    StateConstraint
    
    \* Leader window specific constraints
    LeaderWindowStateConstraint

\* Additional constraints for leader window testing
LeaderWindowStateConstraint ==
    /\ currentSlot <= MaxSlot
    /\ \A v \in Validators : votorView[v] <= MaxView
    /\ Cardinality(messages) <= 100
    /\ Cardinality(deliveredBlocks) <= 20
    /\ \A slot \in 1..MaxSlot : Cardinality(finalizedBlocks[slot]) <= 1

\* Leader window consistency invariant
LeaderWindowConsistency ==
    \A slot \in 1..MaxSlot :
        \A view \in 1..MaxView :
            LET windowIndex == slot \div LeaderWindowSize
                expectedLeader == VRFComputeWindowLeader(windowIndex, Validators, Stake)
                viewLeader == VRFRotateLeaderInWindow(expectedLeader, view, Validators, LeaderWindowSize)
            IN VRFIsLeaderForView(viewLeader, slot, view, Validators, Stake, LeaderWindowSize)

\* VRF determinism invariant
VRFDeterminism ==
    \A slot \in 1..MaxSlot :
        \A v1, v2 \in Validators :
            LET proof1 == VRFGenerateProof(v1, slot)
                proof2 == VRFGenerateProof(v1, slot)
            IN proof1.output = proof2.output

\* Leader window progress property
LeaderWindowProgress ==
    \A windowIndex \in 0..(MaxSlot \div LeaderWindowSize - 1) :
        LET windowStart == windowIndex * LeaderWindowSize + 1
            windowEnd == (windowIndex + 1) * LeaderWindowSize
        IN <>(\E slot \in windowStart..windowEnd :
                \E b \in finalizedBlocks[slot] : TRUE)

\* Window transition liveness property
WindowTransitionLiveness ==
    \A windowIndex \in 0..(MaxSlot \div LeaderWindowSize - 2) :
        LET currentWindow == windowIndex * LeaderWindowSize + 1
            nextWindow == (windowIndex + 1) * LeaderWindowSize + 1
        IN (\E b \in finalizedBlocks[currentWindow] : TRUE) =>
           <>(\E b \in finalizedBlocks[nextWindow] : TRUE)

SYMMETRY
    \* Symmetry reduction for honest validators only
    Permutations({v1, v2})

CHECK_DEADLOCK FALSE

\* View configuration for state visualization
VIEW
    <<currentSlot, votorView, finalizedBlocks>>

\* Action constraints to prevent state explosion
ACTION_CONSTRAINTS
    ActionConstraint

\* Alias for better trace readability
ALIAS
    currentWindow == currentSlot \div LeaderWindowSize
    windowProgress == [w \in 0..(MaxSlot \div LeaderWindowSize - 1) |->
        Cardinality(UNION {finalizedBlocks[s] : s \in (w * LeaderWindowSize + 1)..((w + 1) * LeaderWindowSize)})]
    leaderRotation == [v \in Validators |-> votorView[v]]