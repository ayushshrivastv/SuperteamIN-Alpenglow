SPECIFICATION Spec

\* ========================================================================
\* LARGE-SCALE VERIFICATION CONFIGURATION (50-100 VALIDATORS)
\* 
\* This configuration enables verification of very large networks using:
\* - Statistical model checking for tractable state space exploration
\* - Symmetry reduction to eliminate equivalent states
\* - Abstraction techniques to reduce complexity
\* - Optimized constraints for memory efficiency
\* - Performance benchmarking hooks for end-to-end testing
\* ========================================================================

CONSTANTS
    \* Large validator set for scalability testing (100 validators)
    \* Distributed across honest, Byzantine, and offline categories
    Validators = {
        v1, v2, v3, v4, v5, v6, v7, v8, v9, v10,
        v11, v12, v13, v14, v15, v16, v17, v18, v19, v20,
        v21, v22, v23, v24, v25, v26, v27, v28, v29, v30,
        v31, v32, v33, v34, v35, v36, v37, v38, v39, v40,
        v41, v42, v43, v44, v45, v46, v47, v48, v49, v50,
        v51, v52, v53, v54, v55, v56, v57, v58, v59, v60,
        v61, v62, v63, v64, v65, v66, v67, v68, v69, v70,
        v71, v72, v73, v74, v75, v76, v77, v78, v79, v80,
        v81, v82, v83, v84, v85, v86, v87, v88, v89, v90,
        v91, v92, v93, v94, v95, v96, v97, v98, v99, v100
    }
    
    \* Byzantine validators (20% = 20 validators)
    ByzantineValidators = {
        v81, v82, v83, v84, v85, v86, v87, v88, v89, v90,
        v91, v92, v93, v94, v95, v96, v97, v98, v99, v100
    }
    
    \* Offline validators (20% = 20 validators) 
    OfflineValidators = {
        v61, v62, v63, v64, v65, v66, v67, v68, v69, v70,
        v71, v72, v73, v74, v75, v76, v77, v78, v79, v80
    }
    
    \* Honest online validators (60% = 60 validators)
    \* v1-v60 remain honest and online
    
    \* Reduced bounds for large-scale verification (tuned for 100 validators)
    MaxSlot = 4                    \* Bound tuned for larger networks while keeping tractable
    MaxView = 12                   \* Reduced from protocol max for memory efficiency
    MaxTime = 40                   \* Cap on global logical clock for trace length control
    
    \* Network parameters optimized for large scale
    GST = 4                        \* Global stabilization time (reduced for testing)
    Delta = 1                      \* Message delivery bound
    MaxMessageSize = 1024          \* Kept small for message abstraction
    NetworkCapacity = 200000       \* Increased to accommodate 100 validators
    
    \* Deterministic leader selection for symmetry reduction
    \* Note: LeaderFunction here uses a deterministic ordering on Validators for symmetry reduction
    LeaderFunction(v, Vals) == 
        LET sorted == SortSeq(SetToSeq(Vals), LAMBDA x, y: x < y)
        IN sorted[((Position(sorted, v) - 1) % Len(sorted)) + 1]
    
    MaxBufferSize = 200            \* Buffer size per validator increased for large networks
    PartitionTimeout = 8           \* Timeout tuned for scaling experiments
    
    \* Erasure coding parameters (optimized for bandwidth)
    K = 4                          \* Slightly increased redundancy for resilience
    N = 8                          \* Adjusted total shreds
    MaxBlocks = 8                  \* Fewer blocks per trace for tractability
    BandwidthLimit = 200000        \* Higher aggregate bandwidth limit
    RetryTimeout = 2               \* Retry timing for shreds
    MaxRetries = 2                 \* Limit retries to reduce state explosion
    
    \* Block and transaction limits (scaled for large network)
    MaxBlockSize = 250             \* Reasonable block size for throughput
    BandwidthPerValidator = 2000   \* Per-validator bandwidth cap
    MaxTransactions = 40           \* Transactions per block capped for tractability
    
    \* Protocol parameters (optimized thresholds)
    TimeoutDelta = 3               \* Timeout delta
    InitialLeader = v1             \* Fixed initial leader for reproducibility
    FastPathStake = 80             \* 80% required for fast path
    SlowPathStake = 60             \* 60% required for slow path
    SkipPathStake = 60             \* 60% required for skip path
    
    \* Cryptographic abstractions (scaled limits)
    MaxSignatures = 200            \* Signature tracking limit for large validator sets
    MaxCertificates = 80           \* Certificates tracked for liveness checks

\* ========================================================================
\* STATISTICAL MODEL CHECKING CONFIGURATION
\* ========================================================================

\* Enable statistical model checking mode
\* Statistical model checking configuration (TLC compatible)
\* TLC uses simulation mode instead of statistical model checking
SIMULATION = TRUE
NUM_TRACES = 500                  \* Number of simulation traces
MAX_TRACE_LENGTH = 40             \* Maximum steps per trace (reduced for memory)
RANDOM_SEED = 42                  \* Fixed seed for reproducibility

\* ========================================================================
\* AGGRESSIVE STATE CONSTRAINTS FOR TRACTABILITY
\* ========================================================================

CONSTRAINT
    \* Slot and time bounds
    /\ currentSlot <= MaxSlot
    /\ clock <= MaxTime
    
    \* View bounds per validator
    /\ \A v \in Validators : votorView[v] <= MaxView
    
    \* Message limits (critical for large networks)
    /\ Cardinality(networkMessages) <= 2000        \* Strict but scaled message limit
    /\ Cardinality({m \in networkMessages : m.type = "vote"}) <= 1000
    /\ Cardinality({m \in networkMessages : m.type = "block"}) <= 200
    /\ Cardinality({m \in networkMessages : m.type = "shred"}) <= 800
    
    \* Certificate and vote limits
    /\ Cardinality(certificates) <= MaxCertificates
    /\ Cardinality(votorVotes) <= MaxSignatures
    
    \* Rotor state limits
    /\ Cardinality(rotorShreds) <= N * MaxBlocks
    /\ Cardinality(rotorRepairRequests) <= 50
    
    \* Network partition limits
    /\ Cardinality(networkPartitioned) <= 20      \* Limit partition size to a small subset
    
    \* Memory-critical: Limit finalized blocks tracking
    /\ Cardinality(DOMAIN finalizedBlocks) <= MaxSlot + 1

\* ========================================================================
\* SYMMETRY REDUCTION FOR LARGE NETWORKS
\* ========================================================================

\* Exclude Byzantine and offline validators from symmetry
\* Only permute honest online validators (v1-v60)
\* Symmetry reduction (commented out for compatibility)
\* SYMMETRY Permutations({v1, v2, v3, v4, v5})

\* ========================================================================
\* ACTION CONSTRAINTS FOR EFFICIENCY
\* ========================================================================

\* Action constraints (removed ACTION_CONSTRAINT syntax which is not standard TLC)
    \* Limit concurrent actions per step (scaled to validator count)
    /\ Cardinality({msg \in networkMessages' \ networkMessages : 
                    msg.type = "block"}) <= 10
    /\ Cardinality({msg \in networkMessages' \ networkMessages : 
                    msg.type = "vote"}) <= 400
    /\ Cardinality({msg \in networkMessages' \ networkMessages : 
                    msg.type = "shred"}) <= 100
    
    \* Prevent excessive view changes
    /\ \A v \in Validators : 
        votorView'[v] <= votorView[v] + 1
    
    \* Limit simultaneous timeouts
    /\ Cardinality({v \in Validators : 
                    /\ votorState[v] = "timeout"
                    /\ votorState'[v] # "timeout"}) <= 10

\* ========================================================================
\* ABSTRACTION TECHNIQUES
\* ========================================================================

\* Abstract away detailed cryptographic operations
ABSTRACT_CRYPTO TRUE

\* Use simplified stake calculations
ABSTRACT_STAKE_CALCULATION TRUE

\* Abstract detailed erasure coding mechanics
ABSTRACT_ERASURE_CODING TRUE

\* ========================================================================
\* CORE PROPERTIES TO VERIFY
\* ========================================================================

\* Essential invariants (reduced set for large scale)
INVARIANT TypeOK
INVARIANT Safety                  \* Core safety property
INVARIANT HonestVoteUniqueness    \* Prevent double voting
INVARIANT ChainConsistency        \* Block chain consistency

\* Large-scale specific properties
INVARIANT ScalabilityInvariant    \* Network scales properly
INVARIANT BandwidthConstraints    \* Bandwidth limits respected
INVARIANT MemoryBounds            \* Memory usage within limits

\* Critical resilience properties
PROPERTY LargeScaleResilience     \* 20+20 resilience at scale (20% Byzantine, 20% offline)
PROPERTY ByzantineTolerance       \* Byzantine fault tolerance
PROPERTY PartitionTolerance       \* Network partition tolerance

\* Performance properties
PROPERTY FinalizationProgress     \* Progress despite large network
PROPERTY ScalableConsensus       \* Consensus scales with network size

\* ========================================================================
\* OPTIMIZED EXPLORATION STRATEGY
\* ========================================================================

\* Initial state predicates
INIT Init

\* Next-state relation
NEXT Next

\* Optimized view for state differentiation
\* Focus on key consensus state rather than detailed message contents
VIEW <<currentSlot, 
       [v \in {v1, v2, v3, v4, v5} |-> votorView[v]],  \* Sample of views
       Cardinality(finalizedBlocks[currentSlot]),
       Cardinality(certificates)>>

\* ========================================================================
\* MEMORY AND PERFORMANCE OPTIMIZATIONS
\* ========================================================================

\* Garbage collection hints
GC_FREQUENCY = 10000             \* Collect garbage every 10k states
MAX_HEAP_SIZE = "64g"            \* Increased heap to accommodate large runs

\* Parallel exploration settings
WORKER_THREADS = 16              \* Utilize more cores for larger searches
QUEUE_SIZE = 50000               \* Large work queue for parallel workers

\* Checkpoint settings for long-running verification
CHECKPOINT_INTERVAL = 3600       \* Checkpoint every hour
CHECKPOINT_DIRECTORY = "checkpoints/large_scale"

\* Performance benchmarking hooks
BENCHMARKING_ENABLED = TRUE
BENCHMARK_DURATION = 600         \* Duration in seconds for micro-benchmarking runs
BENCHMARK_METRICS = {"states_per_second", "peak_memory_mb", "cpu_utilization", "message_throughput"}

\* ========================================================================
\* STATISTICAL ANALYSIS CONFIGURATION
\* ========================================================================

\* Properties to analyze statistically
STATISTICAL_PROPERTIES = {
    "SafetyViolationRate",       \* Rate of safety violations
    "LivenessViolationRate",     \* Rate of liveness violations  
    "FinalizationLatency",       \* Average finalization time
    "MessageComplexity",         \* Message overhead per consensus
    "ViewChangeFrequency",       \* Rate of view changes
    "PartitionRecoveryTime"      \* Time to recover from partitions
}

\* Confidence intervals for statistical results
CONFIDENCE_INTERVALS = TRUE
STATISTICAL_REPORTS = TRUE

\* ========================================================================
\* LARGE-SCALE SPECIFIC TESTING SCENARIOS
\* ========================================================================

\* Test scenarios for large networks
TEST_SCENARIOS = {
    "MajorityPartition",         \* Partition affecting >50% validators
    "ByzantineCoordination",     \* Coordinated Byzantine attack
    "CascadingFailures",         \* Multiple simultaneous failures
    "HighLatencyNetwork",        \* Network with high message delays
    "StakeConcentration",        \* High stake concentration scenarios
    "RapidViewChanges"           \* Rapid succession of view changes
}

\* ========================================================================
\* VERIFICATION TARGETS AND GOALS
\* ========================================================================

\* Target metrics for large-scale verification
TARGET_METRICS = {
    "StateSpaceReduction": 90,    \* 90% reduction vs naive exploration
    "MemoryEfficiency": 80,       \* 80% memory efficiency improvement
    "VerificationSpeed": 70,      \* 70% faster than exhaustive search
    "CoverageQuality": 95         \* 95% property coverage confidence
}

\* Success criteria
SUCCESS_CRITERIA = {
    "SafetyAlwaysHolds": TRUE,       \* Safety never violated
    "LivenessEventuallyHolds": TRUE, \* Liveness eventually satisfied
    "ResilienceBoundsRespected": TRUE,\* 20+20 resilience maintained
    "ScalabilityDemonstrated": TRUE   \* Scales to 100 validators
}
