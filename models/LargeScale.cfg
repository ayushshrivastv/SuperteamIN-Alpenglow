SPECIFICATION Spec

\* ========================================================================
\* LARGE-SCALE VERIFICATION CONFIGURATION (20+ VALIDATORS)
\* 
\* This configuration enables verification of large networks using:
\* - Statistical model checking for tractable state space exploration
\* - Symmetry reduction to eliminate equivalent states
\* - Abstraction techniques to reduce complexity
\* - Optimized constraints for memory efficiency
\* ========================================================================

CONSTANTS
    \* Large validator set for scalability testing (25 validators)
    \* Distributed across honest, Byzantine, and offline categories
    Validators = {v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, 
                  v11, v12, v13, v14, v15, v16, v17, v18, v19, v20,
                  v21, v22, v23, v24, v25}
    
    \* Byzantine validators (20% = 5 validators)
    ByzantineValidators = {v21, v22, v23, v24, v25}
    
    \* Offline validators (20% = 5 validators) 
    OfflineValidators = {v16, v17, v18, v19, v20}
    
    \* Honest online validators (60% = 15 validators)
    \* v1-v15 remain honest and online
    
    \* Reduced bounds for large-scale verification
    MaxSlot = 3                    \* Reduced from 5 for tractability
    MaxView = 8                    \* Reduced from 15 for memory efficiency
    MaxTime = 20                   \* Reduced from 30 for faster exploration
    
    \* Network parameters optimized for large scale
    GST = 3                        \* Reduced GST for faster convergence
    Delta = 1                      \* Tighter message delivery bound
    MaxMessageSize = 1024          \* Reduced message size
    NetworkCapacity = 25000        \* Increased for more validators
    
    \* Deterministic leader selection for symmetry reduction
    LeaderFunction(v, Vals) == 
        LET sorted == SortSeq(SetToSeq(Vals), LAMBDA x, y: x < y)
        IN sorted[((v-1) % Len(sorted)) + 1]
    
    MaxBufferSize = 50             \* Reduced buffer size per validator
    PartitionTimeout = 6           \* Reduced timeout for faster recovery
    
    \* Erasure coding parameters (optimized for bandwidth)
    K = 3                          \* Reduced redundancy for efficiency
    N = 5                          \* Reduced total shreds
    MaxBlocks = 5                  \* Fewer blocks for tractability
    BandwidthLimit = 50000         \* Higher limit for more validators
    RetryTimeout = 2               \* Faster retries
    MaxRetries = 2                 \* Fewer retries to reduce state space
    
    \* Block and transaction limits (scaled for large network)
    MaxBlockSize = 200             \* Smaller blocks for faster processing
    BandwidthPerValidator = 1000   \* Reduced per-validator bandwidth
    MaxTransactions = 20           \* Fewer transactions per block
    
    \* Protocol parameters (optimized thresholds)
    TimeoutDelta = 3               \* Reduced timeout delta
    InitialLeader = v1             \* Fixed initial leader
    FastPathStake = 80             \* 80% required for fast path
    SlowPathStake = 60             \* 60% required for slow path
    SkipPathStake = 60             \* 60% required for skip path
    
    \* Cryptographic abstractions (reduced for efficiency)
    MaxSignatures = 30             \* Reduced signature limit
    MaxCertificates = 10           \* Fewer certificates tracked

\* ========================================================================
\* STATISTICAL MODEL CHECKING CONFIGURATION
\* ========================================================================

\* Enable statistical model checking mode
STATISTICAL_MODEL_CHECKING TRUE

\* Sample-based exploration parameters
SAMPLE_SIZE = 10000               \* Number of random traces to explore
MAX_TRACE_LENGTH = 50             \* Maximum steps per trace
CONFIDENCE_LEVEL = 0.95           \* 95% confidence interval
ERROR_MARGIN = 0.05               \* 5% error margin

\* Probabilistic state exploration
RANDOM_SEED = 42                  \* Fixed seed for reproducibility
EXPLORATION_STRATEGY = "uniform"   \* Uniform random exploration

\* ========================================================================
\* AGGRESSIVE STATE CONSTRAINTS FOR TRACTABILITY
\* ========================================================================

CONSTRAINT LargeScaleStateConstraint
STATE_CONSTRAINT
    \* Slot and time bounds
    /\ currentSlot <= MaxSlot
    /\ clock <= MaxTime
    
    \* View bounds per validator
    /\ \A v \in Validators : votorView[v] <= MaxView
    
    \* Message limits (critical for large networks)
    /\ Cardinality(networkMessages) <= 200        \* Strict message limit
    /\ Cardinality({m \in networkMessages : m.type = "vote"}) <= 100
    /\ Cardinality({m \in networkMessages : m.type = "block"}) <= 20
    /\ Cardinality({m \in networkMessages : m.type = "shred"}) <= 50
    
    \* Certificate and vote limits
    /\ Cardinality(certificates) <= MaxCertificates
    /\ Cardinality(votorVotes) <= MaxSignatures
    
    \* Rotor state limits
    /\ Cardinality(rotorShreds) <= N * MaxBlocks
    /\ Cardinality(rotorRepairRequests) <= 10
    
    \* Network partition limits
    /\ Cardinality(networkPartitioned) <= 5       \* Limit partition size
    
    \* Memory-critical: Limit finalized blocks tracking
    /\ Cardinality(DOMAIN finalizedBlocks) <= MaxSlot + 1

\* ========================================================================
\* SYMMETRY REDUCTION FOR LARGE NETWORKS
\* ========================================================================

\* Exclude Byzantine and offline validators from symmetry
\* Only permute honest online validators (v1-v15)
SYMMETRY Permutations({v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, 
                       v11, v12, v13, v14, v15})

\* Additional symmetry for message ordering
SYMMETRY_MESSAGE_ORDER TRUE

\* ========================================================================
\* ACTION CONSTRAINTS FOR EFFICIENCY
\* ========================================================================

ACTION_CONSTRAINT LargeScaleActionConstraint
ACTION_CONSTRAINT
    \* Limit concurrent actions
    /\ Cardinality({msg \in networkMessages' \ networkMessages : 
                    msg.type = "block"}) <= 2
    /\ Cardinality({msg \in networkMessages' \ networkMessages : 
                    msg.type = "vote"}) <= 10
    /\ Cardinality({msg \in networkMessages' \ networkMessages : 
                    msg.type = "shred"}) <= 5
    
    \* Prevent excessive view changes
    /\ \A v \in Validators : 
        votorView'[v] <= votorView[v] + 1
    
    \* Limit simultaneous timeouts
    /\ Cardinality({v \in Validators : 
                    /\ votorState[v] = "timeout"
                    /\ votorState'[v] # "timeout"}) <= 3

\* ========================================================================
\* ABSTRACTION TECHNIQUES
\* ========================================================================

\* Abstract away detailed cryptographic operations
ABSTRACT_CRYPTO TRUE

\* Use simplified stake calculations
ABSTRACT_STAKE_CALCULATION TRUE

\* Abstract detailed erasure coding mechanics
ABSTRACT_ERASURE_CODING TRUE

\* ========================================================================
\* CORE PROPERTIES TO VERIFY
\* ========================================================================

\* Essential invariants (reduced set for large scale)
INVARIANT TypeOK
INVARIANT Safety                  \* Core safety property
INVARIANT HonestVoteUniqueness   \* Prevent double voting
INVARIANT ChainConsistency       \* Block chain consistency

\* Large-scale specific properties
INVARIANT ScalabilityInvariant   \* Network scales properly
INVARIANT BandwidthConstraints   \* Bandwidth limits respected
INVARIANT MemoryBounds          \* Memory usage within limits

\* Critical resilience properties
PROPERTY LargeScaleResilience   \* 20+20 resilience at scale
PROPERTY ByzantineTolerance     \* Byzantine fault tolerance
PROPERTY PartitionTolerance     \* Network partition tolerance

\* Performance properties
PROPERTY FinalizationProgress   \* Progress despite large network
PROPERTY ScalableConsensus     \* Consensus scales with network size

\* ========================================================================
\* OPTIMIZED EXPLORATION STRATEGY
\* ========================================================================

\* Initial state predicates
INIT Init

\* Next-state relation
NEXT Next

\* Optimized view for state differentiation
\* Focus on key consensus state rather than detailed message contents
VIEW <<currentSlot, 
       [v \in {v1, v2, v3, v4, v5} |-> votorView[v]],  \* Sample of views
       Cardinality(finalizedBlocks[currentSlot]),
       Cardinality(certificates)>>

\* ========================================================================
\* MEMORY AND PERFORMANCE OPTIMIZATIONS
\* ========================================================================

\* Garbage collection hints
GC_FREQUENCY = 1000              \* Collect garbage every 1000 states
MAX_HEAP_SIZE = "16g"           \* Maximum heap size for large networks

\* Parallel exploration settings
WORKER_THREADS = 8              \* Use multiple cores
QUEUE_SIZE = 10000             \* Large work queue for parallel workers

\* Checkpoint settings for long-running verification
CHECKPOINT_INTERVAL = 3600      \* Checkpoint every hour
CHECKPOINT_DIRECTORY = "checkpoints/large_scale"

\* ========================================================================
\* STATISTICAL ANALYSIS CONFIGURATION
\* ========================================================================

\* Properties to analyze statistically
STATISTICAL_PROPERTIES = {
    "SafetyViolationRate",       \* Rate of safety violations
    "LivenessViolationRate",     \* Rate of liveness violations  
    "FinalizationLatency",       \* Average finalization time
    "MessageComplexity",         \* Message overhead per consensus
    "ViewChangeFrequency",       \* Rate of view changes
    "PartitionRecoveryTime"      \* Time to recover from partitions
}

\* Confidence intervals for statistical results
CONFIDENCE_INTERVALS = TRUE
STATISTICAL_REPORTS = TRUE

\* ========================================================================
\* LARGE-SCALE SPECIFIC TESTING SCENARIOS
\* ========================================================================

\* Test scenarios for large networks
TEST_SCENARIOS = {
    "MajorityPartition",         \* Partition affecting >50% validators
    "ByzantineCoordination",     \* Coordinated Byzantine attack
    "CascadingFailures",         \* Multiple simultaneous failures
    "HighLatencyNetwork",        \* Network with high message delays
    "StakeConcentration",        \* High stake concentration scenarios
    "RapidViewChanges"           \* Rapid succession of view changes
}

\* ========================================================================
\* VERIFICATION TARGETS AND GOALS
\* ========================================================================

\* Target metrics for large-scale verification
TARGET_METRICS = {
    "StateSpaceReduction": 90,    \* 90% reduction vs naive exploration
    "MemoryEfficiency": 80,       \* 80% memory efficiency improvement
    "VerificationSpeed": 70,      \* 70% faster than exhaustive search
    "CoverageQuality": 95         \* 95% property coverage confidence
}

\* Success criteria
SUCCESS_CRITERIA = {
    "SafetyAlwaysHolds": TRUE,    \* Safety never violated
    "LivenessEventuallyHolds": TRUE, \* Liveness eventually satisfied
    "ResilienceBoundsRespected": TRUE, \* 20+20 resilience maintained
    "ScalabilityDemonstrated": TRUE   \* Scales to 25+ validators
}